# 10-03 Сессия: Архитектура Go Project Starter — слои, драйверы, REST и автогенерация метрик/Grafana
## A. Обзор сессии

Сессия проходила в формате комбинированного знания: преимущественно Domain Knowledge Sharing с элементами Process-Driven и частичной дискуссии (Presentation Style) по архитектурным принципам Go Project Starter. Участники: Speaker 1 (основной носитель знаний/архитектор), Speaker 2 (участник, уточняющий реализацию и конфигурацию), эпизодически Speaker 3. Цель — разъяснить архитектурные концепции (разделение пакетов, понятие application, драйверы, транспорты/генераторы), практики масштабирования и интеграций (Telegram, S3), а также обсудить конфигурацию REST, генерацию клиентов/серверов, и инициативы по автоматизации (валидация конфигов, авто-дашборды для Grafana).

## B. Ключевые выводы

- Разделение слоев и зависимостей:
  - pkg — runtime-библиотеки, максимально общие и переиспользуемые.
  - internal/pkg — генерируемые пакеты, не завязанные на конфиг проекта и специфичные логгеры.
  - internal/app (в речи звучало как “internal lab”/“internal app”) — проектная специфика: общие для проекта библиотеки с зависимостью от конфига, конкретных реализаций (включая логгер).

- Логирование:
  - InternalPKG не должен зависеть от конкретного логгера; функции возвращают ошибки, логирование выполняется на верхнем уровне (в проект-специфичном слое).
  - Возможны разные реализации логгера (пример: The Logo, RusLogo) через единый интерфейс в отдельном пакете.

- Концепция application:
  - Application — атомарная единица горизонтального масштабирования (контейнер).
  - Один бинарь/контейнер может включать несколько компонентов (HTTP-серверы, воркеры), которые инициализируются/запускаются параллельно (горутины).
  - Выбор сервисов (HTTP/worker и т. п.) определяется конфигурацией, каждый application масштабируется независимо.

- Драйверы:
  - Драйвер — слой интеграции между бизнес-логикой и внешним API (Telegram, S3 и т. д.) по стабильному интерфейсу.
  - Принцип: сервис вызывает абстрактный интерфейс (например, “отправь сообщение”), драйвер переводит вызов в конкретный API.
  - Драйверы реализуют интерфейс Runnable (init, run, shutdown, graceful shutdown). Запускаются до сервиса; у активных интеграций (Telegram — веб-хуки/веб-сокеты) есть фоновые процессы, у пассивных (S3) — нет.
  - Замена провайдера проста: меняется драйвер/библиотека без изменения бизнес-логики (пример: переход с Azure S3 на DigitalOcean S3).

- Транспорты и генерация:
  - Transport “sys” из template — генерация преднастроенного сервера для прометеус-метрик (prometheus metrics), стартующего в составе application.
  - Генераторы типов:
    - gen-client — генерирует клиентскую библиотеку и интегрирует её в сервис (инициализация при старте).
    - gen-server — генерирует сервер и будет запущен в будущем (в составе application).

- REST в Project Config:
  - REST — это JSON RESTful API, не gRPC.
  - Определённые REST-сервисы должны быть назначены в конкретные application; иначе генерация падает (требуется валидация).
  - REST-сервер выставляет ручки наружу; REST-клиент генерирует клиентский код и предоставляет доступ к нему через сервис.

- Долги/несоответствия:
  - Временная путаница с пакетами Telegram (pkg, internal/pkg, internal/app) из-за незавершённого рефакторинга; возможны алиасы и смешение импортов — лучше эскалировать на автора для ускорения чистки.

- Инициативы:
  - Добавить валидацию конфигов (проверка непротиворечивости: определено в REST, но не привязано к application — ошибка).
  - Автогенерация дашбордов для Grafana на основе метрик — высокая приоритетность и практическая полезность.

## C. Вопросы и уточнения
- Что означает транспорт sys и генератор type/template?
  - Ответ: transport sys из шаблонов — генерация сервера для Prometheus metrics; “generator type = template” означает генерацию по готовым шаблонам. “gen-client”/“gen-server” — разные режимы генерации (клиент vs сервер).

- Что значит REST в Project Config?
  - Ответ: REST — JSON RESTful API (не gRPC).

REST-сервисы должны быть назначены на конкретные application; иначе генерация валится — нужна валидация.

- Ошибка при генерации из-за REST без назначения в application:
  - Ответ: Да, это следует валидировать; лишние описания без использования — как “неиспользуемый импорт” в Go, лучше блокировать.
- Статус ToDo в README:
  - Ответ: Актуально; используется для планирования работ, можно пополнять и делегировать новичкам.

Открытые вопросы/незакрытые моменты:
- Уточнить финальную структуру и именование слоев (internal/app vs “internal lab”): стандартизировать термин.
- Определить правила размещения интеграций (например, Telegram) между pkg/internal/pkg/internal/app и провести рефакторинг для устранения дублирования.
- Подтвердить формат и источники метрик для автогенерации Grafana дашбордов (какие экспортеры и labels, схема).

## E. Предлагаемое содержание документации

### Архитектурные слои и зависимости

- pkg (runtime):
  - Назначение: общие библиотеки, не завязанные на конфиг проекта.
  - Требования: отсутствие зависимостей на конкретные реализация логгера/интеграций.
- internal/pkg (generated core):
  - Назначение: генерируемый код, переиспользуемый между проектами Go Project Starter.
  - Требования: не зависит от проекта-специфичных настроек; ошибки возвращаются вверх, логирование — выше по стеку.
- internal/app (project-specific shared):
  - Назначение: библиотеки и код, разделяемый внутри конкретного проекта; может зависеть от конфига и конкретных реализаций (логгер, драйверы).
  - Пример: подключение выбранного логгера, специфичные адаптеры.

Лучшие практики:
- Чёткое разделение бизнес-логики и интеграций.
- Интерфейсы в бизнес-слое, реализация — в драйверах.
- Минимизировать кросс-слойные зависимости, избегать специфики в pkg/internal/pkg.

### Концепция Application
- Определение: атомарная единица горизонтального масштабирования; соответствует контейнеру.
- Состав: может включать несколько компонентов (HTTP серверы, воркеры, драйверы).
- Поведение при старте:
  - Инициализация всех указанных HTTP серверов из конфига.
  - Запуск воркеров в отдельных горутинах.
  - Предварительный запуск всех драйверов (Runnable).
- Масштабирование:
  - Каждый application масштабируется независимо; одна кодовая база — несколько application профилей.

### Драйверы интеграций
- Назначение: адаптация стабильного сервисного интерфейса к внешнему API (Telegram, S3).
- Интерфейс:
  - Runnable: init, run, shutdown, graceful shutdown.
  - Сервисный интерфейс: доменные операции (например, SendMessage, PutFile, GetFile, Hash, Size).
- Жизненный цикл:
  - До старта сервисов запускаются драйверы; активные драйверы могут слушать сокеты/веб-хуки.
- Замена провайдера:
  - Реализовать новый драйвер, соблюдающий интерфейс; сервисный код не меняется.

### Транспорты и генерация
- Transport “sys” (template):
  - Автогенерация сервера для экспонирования Prometheus метрик.
  - Включение в application запускает метрик-сервер.
- Генераторы:
- gen-client: генерирует клиентскую библиотеку, интегрирует её инициализацию в сервис.
  - gen-server: генерирует серверную часть для будущего запуска.
  - generator type = template: использование шаблонов из репозитория для генерации артефактов.

### Конфигурация REST
- REST = JSON RESTful API (не gRPC).
- Правила:
  - Определённые REST-сервисы должны быть связаны с конкретными application.
  - REST-сервер — выставляет ручки наружу.
  - REST-клиент — генерирует клиентскую библиотеку и делает её доступной через сервис.
- Валидация:
  - Генерация должна падать/предупреждать, если REST описан, но не используется в application.

### Логирование
- Интерфейс логгера:
  - Реализации взаимозаменяемы (The Logo, RusLogo и т. п.) через общий интерфейс.
- Правило слоёв:
  - internal/pkg — без привязки к конкретному логгеру (только возврат ошибок).
  - Логирование в application/internal слоях.

### Известные проблемы и рекомендации
- Telegram пакеты в трёх местах (pkg, internal/pkg, internal/app):
  - Временная мера из-за незавершённого рефакторинга; возможны алиасы и смешение импортов.
  - Рекомендация: при боли — эскалировать автору (Speaker 1) для ускоренной чистки.
- Общая валидация конфигов:
  - Проверять непротиворечивость и полноту; аналог “неиспользуемого импорта” в Go.

### План автогенерации Grafana дашбордов (черновик)
- Источники метрик:
  - Prometheus metrics из transport sys и компонент (HTTP, worker, драйверы).
- Стандартные панели:
  - HTTP: RPS, latency (p50/p90/p99), ошибки по кодам, saturation.
  - Worker: обработанные задачи, retry/fail rates, время обработки.
  - Драйверы: внешние вызовы, ошибки/таймауты, очереди/подписки (для Telegram).
- Интеграция:
  - Генератор дашбордов на основе конфигов application и метрик-лейблов.
  - Автоприменение/экспорт JSON/Mixin для Grafana.

### FAQ
- В: Почему генерация падает, если REST не привязан к application?
  - О: Описанные сущности должны быть использованы. Добавьте соответствующее назначение или удалите лишнее.
- В: Можно ли менять поставщика S3 без переписывания сервиса?
  - О: Да, замените драйвер, соблюдая интерфейс; сервисные вызовы не меняются.
- В: Где должно происходить логирование?
  - О: В проект-специфичных слоях (application/internal), не в internal/pkg.

### SOP: Валидация Project Config (черновик)
- Шаги:
  1. Парсинг Project Config.
  2. Проверка: каждая сущность REST (server/client) назначена хотя бы одному application.
  3. Проверка транспортов: transport sys указан — метрик-сервер должен быть сконфигурирован (порт, пути).
  4. Проверка генераторов: gen-client/gen-server соответствуют ожидаемым целям; отсутствуют “висячие” генерации без использования.
  5. Отчёт: ошибки/варнинги с указанием пути в конфиге.
- Инструменты:
  - Встроенный валидатор генератора.
  - Сбор тудушек из кода/сгенерированной документации для дальнейших задач.

### Пример жизненного цикла Application
- Инициализация:
  - Загрузка конфига, создание логгера (проект-специфический).
  - Инициализация драйверов (init).
- Запуск:
  - Запуск драйверов (run): Telegram слушает веб-сокет/веб-хуки; S3 — no-op.
  - Запуск HTTP серверов.
  - Запуск воркеров в отдельных горутинах.
- Завершение:
  - Graceful shutdown: остановка воркеров/HTTP, shutdown драйверов.

### Термины
- Application — контейнеризуемая единица, атомарно масштабируемая.
- Driver — адаптер для внешних API с Runnable.
- Runnable — интерфейс жизненного цикла (init/run/shutdown/graceful).
- Transport sys — метрик-сервер (Prometheus) из шаблона.
- gen-client/gen-server — режимы генерации клиента/сервера.
- REST — JSON RESTful API, не gRPC.

### Риски и подводные камни
- Смешение пакетов интеграций в разных слоях → сложные алиасы, повышенная связность.
- Отсутствие валидации конфига → падения генерации, “мертвые” сущности.
- Нарушение принципа независимости internal/pkg → утечки зависимостей (логгер/конфиг).

### Ресурсы и инструменты
- Репозиторий Go Project Starter: шаблоны для транспортов и генераторов.
- README/ToDo: актуальные задачи, подходящие “good first issues”.
- Prometheus/Grafana: стандартные экспортеры и JSON-модели дашбордов.
