- gen-client: генерирует клиентскую библиотеку, интегрирует её инициализацию в сервис.
  - gen-server: генерирует серверную часть для будущего запуска.
  - generator type = template: использование шаблонов из репозитория для генерации артефактов.
### Конфигурация REST
- REST = JSON RESTful API (не gRPC).
- Правила:
  - Определённые REST-сервисы должны быть связаны с конкретными application.
  - REST-сервер — выставляет ручки наружу.
  - REST-клиент — генерирует клиентскую библиотеку и делает её доступной через сервис.
- Валидация:
  - Генерация должна падать/предупреждать, если REST описан, но не используется в application.
### Логирование
- Интерфейс логгера:
  - Реализации взаимозаменяемы (The Logo, RusLogo и т. п.) через общий интерфейс.
- Правило слоёв:
  - internal/pkg — без привязки к конкретному логгеру (только возврат ошибок).
  - Логирование в application/internal слоях.
### Известные проблемы и рекомендации
- Telegram пакеты в трёх местах (pkg, internal/pkg, internal/app):
  - Временная мера из-за незавершённого рефакторинга; возможны алиасы и смешение импортов.
  - Рекомендация: при боли — эскалировать автору (Speaker 1) для ускоренной чистки.
- Общая валидация конфигов:
  - Проверять непротиворечивость и полноту; аналог “неиспользуемого импорта” в Go.
### План автогенерации Grafana дашбордов (черновик)
- Источники метрик:
  - Prometheus metrics из transport sys и компонент (HTTP, worker, драйверы).
- Стандартные панели:
  - HTTP: RPS, latency (p50/p90/p99), ошибки по кодам, saturation.
  - Worker: обработанные задачи, retry/fail rates, время обработки.
  - Драйверы: внешние вызовы, ошибки/таймауты, очереди/подписки (для Telegram).
- Интеграция:
  - Генератор дашбордов на основе конфигов application и метрик-лейблов.
  - Автоприменение/экспорт JSON/Mixin для Grafana.
### FAQ
- В: Почему генерация падает, если REST не привязан к application?
  - О: Описанные сущности должны быть использованы. Добавьте соответствующее назначение или удалите лишнее.
- В: Можно ли менять поставщика S3 без переписывания сервиса?
  - О: Да, замените драйвер, соблюдая интерфейс; сервисные вызовы не меняются.
- В: Где должно происходить логирование?
  - О: В проект-специфичных слоях (application/internal), не в internal/pkg.
### SOP: Валидация Project Config (черновик)
- Шаги:
  1. Парсинг Project Config.
  2. Проверка: каждая сущность REST (server/client) назначена хотя бы одному application.
  3. Проверка транспортов: transport sys указан — метрик-сервер должен быть сконфигурирован (порт, пути).
  4. Проверка генераторов: gen-client/gen-server соответствуют ожидаемым целям; отсутствуют “висячие” генерации без использования.
  5. Отчёт: ошибки/варнинги с указанием пути в конфиге.
- Инструменты:
  - Встроенный валидатор генератора.
  - Сбор тудушек из кода/сгенерированной документации для дальнейших задач.
### Пример жизненного цикла Application
- Инициализация:
  - Загрузка конфига, создание логгера (проект-специфический).
  - Инициализация драйверов (init).
- Запуск:
  - Запуск драйверов (run): Telegram слушает веб-сокет/веб-хуки; S3 — no-op.
  - Запуск HTTP серверов.
  - Запуск воркеров в отдельных горутинах.
- Завершение:
  - Graceful shutdown: остановка воркеров/HTTP, shutdown драйверов.
### Термины
- Application — контейнеризуемая единица, атомарно масштабируемая.
- Driver — адаптер для внешних API с Runnable.
- Runnable — интерфейс жизненного цикла (init/run/shutdown/graceful).
- Transport sys — метрик-сервер (Prometheus) из шаблона.
- gen-client/gen-server — режимы генерации клиента/сервера.
- REST — JSON RESTful API, не gRPC.
### Риски и подводные камни
- Смешение пакетов интеграций в разных слоях → сложные алиасы, повышенная связность.
- Отсутствие валидации конфига → падения генерации, “мертвые” сущности.
- Нарушение принципа независимости internal/pkg → утечки зависимостей (логгер/конфиг).
### Ресурсы и инструменты
- Репозиторий Go Project Starter: шаблоны для транспортов и генераторов.
- README/ToDo: актуальные задачи, подходящие “good first issues”.
- Prometheus/Grafana: стандартные экспортеры и JSON-модели дашбордов.
