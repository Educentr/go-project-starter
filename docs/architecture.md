# Архитектура

## Трёхслойный дизайн

Go Project Starter использует чистую, масштабируемую архитектуру с разделением ответственности:

```
┌─────────────────────────────────────────────────────────────┐
│  pkg/                  Runtime-библиотеки                   │
│  ├── app/              Жизненный цикл приложения            │
│  ├── drivers/          Внешние интеграции                   │
│  └── rest/             Сгенерированные REST клиенты         │
│                        (Без зависимости от конфига)         │
└─────────────────────────────────────────────────────────────┘
                            ▲
                            │
┌─────────────────────────────────────────────────────────────┐
│  internal/pkg/         Генерируемая бизнес-логика           │
│  ├── model/            Модели данных и сущности             │
│  ├── service/          Интерфейсы бизнес-логики             │
│  └── repository/       Паттерны доступа к данным            │
│                        (Независима от конфига)              │
└─────────────────────────────────────────────────────────────┘
                            ▲
                            │
┌─────────────────────────────────────────────────────────────┐
│  internal/app/         Проект-специфичный код               │
│  ├── transport/        REST/gRPC обработчики                │
│  │   ├── rest/api/v1/  OpenAPI-генерируемые handlers        │
│  │   └── grpc/users/   gRPC реализации                      │
│  └── worker/           Фоновые воркеры                      │
│      ├── telegram_bot/ Реализации ботов                     │
│      └── kafka_orders/ Event consumers                      │
│                        (Может использовать конфиг)          │
└─────────────────────────────────────────────────────────────┘
```

### Слой `pkg/` (Runtime)

**Назначение:** Общие библиотеки, максимально переиспользуемые.

**Требования:**
- Отсутствие зависимостей от конфига проекта
- Отсутствие зависимостей от конкретных реализаций логгера

### Слой `internal/pkg/` (Generated Core)

**Назначение:** Генерируемый код, переиспользуемый между проектами.

**Требования:**
- Не зависит от проект-специфичных настроек
- Функции возвращают ошибки вверх, логирование выполняется на верхнем уровне
- Не привязан к конкретному логгеру

### Слой `internal/app/` (Project-Specific)

**Назначение:** Код, специфичный для конкретного проекта.

**Характеристики:**
- Может зависеть от конфига
- Может использовать конкретные реализации (логгер, драйверы)
- Содержит бизнес-логику обработчиков

## Сохранение пользовательского кода

**Главная фишка:** Перегенерируйте весь проект без потери ваших изменений.

Каждый сгенерированный файл содержит disclaimer-маркер:

```go
// ==========================================
// GENERATED CODE - DO NOT EDIT ABOVE THIS LINE
// Changes manually made below will not be overwritten by generator.
// ==========================================

func (h *Handler) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {
    // Ваша бизнес-логика здесь
    // Этот код переживёт регенерацию!

    user := &User{
        Email: req.Email,
        Name:  req.Name,
    }

    // Кастомная валидация
    if err := h.validateBusinessRules(user); err != nil {
        return nil, err
    }

    return h.repo.Create(ctx, user)
}
```

**Правила:**
1. Код выше маркера регенерируется при каждом запуске
2. Код ниже маркера сохраняется навсегда
3. Если нужно изменить сгенерированный код - переместите его ниже маркера

## Концепция Application

**Application** — атомарная единица горизонтального масштабирования (контейнер).

### Характеристики

- Один бинарь/контейнер может включать несколько компонентов
- HTTP серверы, gRPC серверы, воркеры - инициализируются и запускаются параллельно
- Каждый application масштабируется независимо

```yaml
applications:
  # API Gateway с REST и gRPC
  - name: gateway
    transport: [rest_api, grpc_users]

  # Выделенный worker instance
  - name: workers
    workers: [telegram_bot, kafka_consumer]

  # Всё-в-одном для небольших деплоев
  - name: monolith
    transport: [rest_api, grpc_users]
    workers: [telegram_bot]
```

### Жизненный цикл Application

```
┌──────────────────────────────────────────────────────────────┐
│                    ИНИЦИАЛИЗАЦИЯ                             │
│  1. Загрузка конфига                                         │
│  2. Создание логгера (проект-специфичный)                    │
│  3. Инициализация драйверов (init)                           │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                       ЗАПУСК                                 │
│  1. Запуск драйверов (run): Telegram слушает webhook/socket  │
│  2. Запуск HTTP серверов                                     │
│  3. Запуск gRPC серверов                                     │
│  4. Запуск воркеров в отдельных горутинах                    │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                    ЗАВЕРШЕНИЕ                                │
│  1. Graceful shutdown: остановка воркеров                    │
│  2. Остановка HTTP/gRPC серверов                             │
│  3. Shutdown драйверов                                       │
└──────────────────────────────────────────────────────────────┘
```

## Транспорты

Транспорт — слой доставки запросов к сервису.

| Транспорт | Протокол | Жизненный цикл | Интерактивность |
|-----------|----------|----------------|-----------------|
| **REST** | HTTP/JSON | Слушает порт → обрабатывает запросы | Нет |
| **gRPC** | HTTP2/protobuf | Слушает порт → обрабатывает запросы | Нет |
| **CLI** | stdin/stdout | Получает команду → выполняет → завершается | Да |
| **Kafka** | Kafka protocol | Слушает топики → обрабатывает события | Нет |

## Драйверы интеграций

**Драйвер** — адаптер между бизнес-логикой и внешним API (Telegram, S3, и т.д.)

### Принцип работы

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│    Service      │────▶│    Interface    │◀────│     Driver      │
│  (бизнес-логика)│     │  (SendMessage)  │     │  (Telegram API) │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

- Сервис вызывает абстрактный интерфейс ("отправь сообщение")
- Драйвер транслирует вызов в конкретный API
- Замена провайдера проста: меняется драйвер без изменения бизнес-логики

### Интерфейс Runnable

Все драйверы реализуют интерфейс `Runnable`:

```go
type Runnable interface {
    Init(ctx context.Context) error
    Run(ctx context.Context) error
    Shutdown(ctx context.Context) error
    GracefulShutdown(ctx context.Context) error
}
```

- **Активные драйверы** (Telegram) — имеют фоновые процессы (webhooks/websockets)
- **Пассивные драйверы** (S3) — no-op в методе Run

### Пример замены провайдера

```yaml
# Переход с AWS S3 на DigitalOcean Spaces
drivers:
  - name: storage
    type: s3
    provider: digitalocean  # Просто измените эту строку
    config:
      endpoint: nyc3.digitaloceanspaces.com
```

## Типы генераторов

### REST генераторы

| Тип | Описание | Применение |
|-----|----------|------------|
| `ogen` | OpenAPI 3.0 кодогенерация | Основные бизнес API |
| `template` | Шаблонная генерация | Health checks, метрики, кастомные endpoints |
| `ogen_client` | REST клиент | Вызов внешних API |

### Специальные шаблоны

- **`sys`** — сервер для Prometheus метрик, health checks, pprof

## Структура директорий генератора

```
go-project-starter/
├── cmd/go-project-starter/    # CLI точка входа
├── internal/pkg/
│   ├── config/                # Загрузка YAML конфигов
│   ├── generator/             # Оркестрация генерации
│   ├── templater/             # Движок шаблонов
│   │   └── embedded/templates/
│   │       ├── main/          # Makefile, Dockerfile, configs
│   │       ├── transport/     # REST, gRPC, Kafka
│   │       ├── worker/        # Telegram, daemon
│   │       ├── app/           # Application layer
│   │       └── logger/        # Logger implementations
│   ├── meta/                  # Версионирование
│   └── ds/                    # Domain structures
└── example/                   # Примеры конфигураций
```

## Следующие шаги

- [Конфигурация](configuration.md) - полное руководство по настройке
- [Возможности](features.md) - все возможности генератора
- [Продвинутые темы](advanced.md) - драйверы, OnlineConf, Grafana
