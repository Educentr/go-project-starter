package mw

import (
	"context"
	"net/http"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/prometheus/client_golang/prometheus"

	"{{ .ProjectPath }}/pkg/app/ds"
	"{{ .ProjectPath }}/pkg/reqctx"
	"{{ .ProjectPath }}/pkg/app/rest"
)

type DefaultMiddlewares struct{}
type EmptyMiddlewares struct{}

func (dmw *DefaultMiddlewares) GetMiddlewares(
	ctx context.Context,
	metrics *prometheus.Registry,
	srv ds.IService,
	name string,
	errHdl rest.RestErrorHandler,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	// Мидлвари работают в том порядке в котором они находятся в этом массиве
	// Изменение порядка может сильно повлиять на работу сервиса, делать это надо только если вы уверенны что происходит
	mws := []func(next http.Handler) http.Handler{
		// Создаём контекст запроса
		func(next http.Handler) http.Handler {
			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				ctx, cancel := reqctx.CreateContext(ctx, r.RequestURI)
				next.ServeHTTP(w, r.WithContext(ctx))
				cancel()
			})
		},
		HTTPServerMiddlewareRequestStartTime(),                     // Обогащаем контекст временем начала запроса
		HTTPServerMiddlewareTracing(ctx),                           // Обогащаем контекст запроса ID для трейсинга
		HTTPServerMiddlewareMetrics(ctx, name, metrics),            // Инициализируем метрики, добавляем инфу о времени старта обработки запроса и т.д.
		HTTPServerMiddlewareXServerHeader(ctx, name),               // Обогащаем ответ заголовком X-Server
	}

	httpAuthEnable, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/httpAuth/enabled", true)
	if err != nil {
		return nil, fmt.Errorf("error get httpAuth enabled: %w", err)
	}

	if httpAuthEnable {
		mws = append(mws, HTTPServerMiddlewareAuth(ctx, srv.GetAuthorizer(), errHdl))
	}

	csrfEnabled, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/csrf/enabled", false)
	if err != nil {
		return nil, fmt.Errorf("error get csrf enabled: %w", err)
	}

	if csrfEnabled {
		mws = append(mws, HTTPServerMiddlewareCSRF(ctx, srv.GetAuthorizer(), errHdl))
	}

	return mws, nil
}

func (emw *EmptyMiddlewares) GetMiddlewares(
	_ context.Context,
	_ *prometheus.Registry,
	_ ds.IService,
	_ string,
	_ rest.RestErrorHandler,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	return []func(next http.Handler) http.Handler{}, nil
}

/*TODO ogen
func panicRecoverFunc(ctx context.Context) func(ctx context.Context, p interface{}) (err error) {
	ctxLogger := zlog.Ctx(ctx)

	return func(ctx context.Context, p interface{}) (err error) {
		ctxLogger.Error().Interface("Panic", p).Bytes("Stack trace", debug.Stack()).Msg("Panic triggered")
		return status.Errorf(codes.Unknown, "panic triggered: %v", p)
	}
}
*/
