package rest

import (
	"context"
	"fmt"
	"net/http"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}
	"golang.org/x/sync/errgroup"
	
	"{{ .ProjectPath }}/pkg/app/ds"
)

type Server struct {
	// Имя транспорта
	name string

	// HTTP сервер
	httpSrv *http.Server

	// Сервис с бизнес логикой приложения
	srv ds.IService

	// АПИ как презентационный уровень для сервиса
	router Router
}

const (
	nameFieldLogger = "Name"
)

func (s *Server) GetHTTPServer(ctx context.Context, serviceName string) (*http.Server, error) {
	ip, err := onlineconf.GetString(ctx, onlineconf.MakePath(serviceName, "transport/rest/"+s.Name()+"/ip"), defaultListenIP)
	if err != nil {
		ip = defaultListenIP

		{{ .Logger.ErrorMsg "ctx" "err" "error getting ip from onlineconf" "Str(\"Default\", defaultListenIP)" }}
	}

	port, ex, err := onlineconf.GetStringIfExists(ctx, onlineconf.MakePath(serviceName, "transport/rest/"+s.Name()+"/port"))
	if err != nil {
		return nil, fmt.Errorf("error get port: %w", err)
	}

	if !ex {
		return nil, errors.New("port not found")
	}

	timeout, err := onlineconf.GetDuration(ctx, onlineconf.MakePath(serviceName, "transport/rest/"+s.Name()+"/timeout"), defaultHTTPTimeout)
	if err != nil {
		timeout = defaultHTTPTimeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting timeout from onlineconf" "Str(\"Default\", defaultHTTPTimeout.String())"}}
	}

	headerTimeout, err := onlineconf.GetDuration(ctx, onlineconf.MakePath(serviceName, "transport/rest/"+s.Name()+"/timeout_read_header"), timeout)
	if err != nil {
		headerTimeout = timeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting timeout read header from onlineconf. Set to timeout"}}
	}

	// ToDo split timeout for read and write
	return &http.Server{
		Addr:              ip + ":" + port,
		WriteTimeout:      timeout,
		ReadTimeout:       timeout,
		IdleTimeout:       timeout,
		ReadHeaderTimeout: headerTimeout,
	}, nil
}

func NewServer(name string, router Router) *Server {
	return &Server{
		name:   name,
		router: router,
	}
}

func (s *Server) Name() string {
	return s.name
}

func (s *Server) Init(ctx context.Context, serviceName string, metrics *prometheus.Registry, srv ds.IService) error {
	var err error

	s.srv = srv

	s.httpSrv, err = s.GetHTTPServer(ctx, serviceName)
	if err != nil {
		return errors.Wrap(err, "http server initialization")
	}

	err = s.router.InitRouters(ctx, s.httpSrv, s.srv, metrics)
	if err != nil {
		return errors.Wrap(err, "error initialization API Routers")
	}

	mws, err := s.router.GetMiddlewares(ctx, metrics, srv, s.Name(), s.router.GetErrorHandler())
	if err != nil {
		return errors.Wrap(err, "error initialization API middlewares")
	}

	for i := len(mws); i > 0; i-- {
		s.httpSrv.Handler = mws[i-1](s.httpSrv.Handler)
	}

	return nil
}

func (s *Server) Run(ctx context.Context, errGr *errgroup.Group) {
	{{ .Logger.InfoMsg "ctx" "Run rest server" "Str(nameFieldLogger, s.name)"}}

	// initialization http server
	errGr.Go(func() error {
		{{ .Logger.InfoMsg "ctx" "server started serving" "Str(\"addr\", s.httpSrv.Addr)" "Str(nameFieldLogger, s.name)" }}

		err := s.httpSrv.ListenAndServe()
		if err != nil {
			if errors.Is(err, http.ErrServerClosed) {
				return nil
			}

			{{ .Logger.ErrorMsg "ctx" "err).Str(nameFieldLogger, s.name" "server initialization/runtime error"}}
		}

		return err
	})
}
