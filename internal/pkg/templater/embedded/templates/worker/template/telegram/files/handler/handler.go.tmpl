package handler

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"{{ .ProjectPath }}/internal/pkg/service"
	"{{ .ProjectPath }}/pkg/drivers/telegram"
)

type Handler struct {
	telegram.DefaultHandler
	srv    *service.EmptyService // ToDo надо сделать интерфейс а не ссылку на конкретную структуру
	Rd    	telegram.RequestData
}

type EmptyParams struct{}

type BackButtonParams struct {
	Back telegram.ButtonCmd
	Del bool
}

var (
	ErrEmptyParam              = errors.New("empty parameter")
	ErrInvalidParam            = errors.New("invalid parameter")
	ErrParamsNotEnough         = errors.New("not enough parameters")
)

var (
	UnimplementedResponse = telegram.Response{
		Messages: []telegram.Message{
			{
				Text:   "Unimplemented command",
				Btn:    [][]telegram.ButtonCmd{},
			},
		},
	}
)

func NewHandler(srv *service.EmptyService, rd telegram.RequestData) *Handler {
	return &Handler{
		srv:    srv,
		Rd: 	rd,
	}
}

func (e *EmptyParams) Unpack(_ context.Context, _ string) error {
	return nil
}

func (e *EmptyParams) Pack() string {
	return ""
}

func (p *BackButtonParams) Pack() string {
	if p.Back.Name == "" {
		return ""
	}

	return strings.Join([]string{string(p.Back.Name), p.Back.Text, p.Back.URL, p.Back.Params}, "\x00")
}

func (p *BackButtonParams) Unpack(_ context.Context, params string) error {
	if params == "" {
		return nil
	}

	parts := strings.SplitN(params, "\x00", 4)
	if len(parts) != 4 {
		return fmt.Errorf("invalid params format: %s", params)
	}

	if parts[0] == "" {
		return fmt.Errorf("empty command name in params: %s", params)
	}

	p.Back.Name = telegram.CommandName(parts[0])
	p.Back.Text = parts[1]
	p.Back.URL = parts[2]
	p.Back.Params = parts[3]

	return nil
}
