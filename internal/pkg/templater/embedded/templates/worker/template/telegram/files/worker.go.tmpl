package telegrambot

import (
	"context"
	"errors"

	{{ .Logger.Import }}

	"{{ .ProjectPath }}/internal/app/worker/telegrambot/handler"
	"{{ .ProjectPath }}/pkg/drivers/telegram"
)

var cmdMaps = make(map[telegram.CommandName]telegram.Cmd)

var CustomError = map[error]func(ctx context.Context) (telegram.Response, error){}

func (w *Worker) processRequest(ctx context.Context, hdl *handler.Handler, c telegram.Cmd, pp string) {
	if hdl.Rd.Actor.ID == 0 {
		{{ .Logger.ErrorMsg "ctx" "nil" "Actor ID is zero" }}

		return
	}

	for {
		aclErr := w.Authorization(ctx, hdl.Rd)
		if aclErr != nil {
			w.HandleAuthError(ctx, hdl.Rd, aclErr)

			return
		}

		resp, err := c.Handler(ctx, hdl, pp)
		if resp.InternalRedirect != nil {
			var ok bool
			c, ok = cmdMaps[resp.InternalRedirect.Cmd]
			if !ok {
				{{ .Logger.ErrorMsg "ctx" "nil" "Unknown command for internal redirect" "Str(\"Cmd\", resp.InternalRedirect.Cmd.String())" }}

				w.postProcessRequest(ctx, hdl.Rd, telegram.Response{}, telegram.ErrInternalError)

				return
			}

			pp = resp.InternalRedirect.Params
			continue
		}

		w.postProcessRequest(ctx, hdl.Rd, resp, err)

		break
	}

	return
}

func (w *Worker) HandleAuthError(ctx context.Context, requestData telegram.RequestData, aclErr error) {
	for cErr, cFunc := range CustomError {
		if errors.Is(aclErr, cErr) {
			resp, err := cFunc(ctx)
			w.postProcessRequest(ctx, requestData, resp, err)

			return
		}
	}

	if errors.Is(aclErr, telegram.ErrUserNotFound) {
		{{ .Logger.ErrorMsg "ctx" "aclErr" "Admin not found. Skip" }}

		w.postProcessRequest(ctx, requestData, telegram.Response{}, nil)

		return
	}

	if errors.Is(aclErr, telegram.ErrAccessDenied) {
		{{ .Logger.ErrorMsg "ctx" "aclErr" "Access denied" }}

		w.postProcessRequest(ctx, requestData, telegram.Response{}, nil)

		return
	}

	{{ .Logger.ErrorMsg "ctx" "aclErr" "Error checking ACL" }}

	w.postProcessRequest(ctx, requestData, telegram.Response{}, telegram.ErrInternalError)

	return
}

func (w *Worker) postProcessRequest(ctx context.Context, requestData telegram.RequestData, resp telegram.Response, err error) {
	if requestData.Actor.ID == 0 {
		{{ .Logger.ErrorMsg "ctx" "nil" "Actor ID is zero in postProcessRequest" }}

		return
	}

	notifyMsg := resp.NotifyMsg

	switch {
	case err != nil:
		{{ .Logger.ErrorMsg "ctx" "err" "Error processing command" }}

		resp.Messages = []telegram.Message{ {
			Text:      err.Error(),
		} }

		if notifyMsg != "" {
			notifyMsg = err.Error()
		}

	case resp.NextState != nil:
		// Record state change metric
		if w.tgMetrics != nil {
			oldState, _ := w.GetUserState(ctx, requestData.Actor.ID)
			w.tgMetrics.UserStateChanges.WithLabelValues(oldState, *resp.NextState).Inc()
		}

		if err := w.NewUserState(ctx, requestData.Actor.ID, *resp.NextState); err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Error setting admin state" }}

			resp.Messages = []telegram.Message{ {
				Text: "Internal error",
			} }

			if notifyMsg != "" {
				notifyMsg = "Internal error"
			}
		}
	}

	srv, errSrv := w.GetEmptySrv()
	if errSrv != nil {
		{{ .Logger.ErrorMsg "ctx" "errSrv" "Error getting service" }}

		return
	}

	if resp.DeleteLastMsg {
		msgID, err := w.GetLastMsgToUser(ctx, requestData.Actor.ID)
		if err != nil || msgID == 0 {
			notifyMsg = "Error getting last message ID"

			{{ .Logger.ErrorMsg "ctx" "err" "Error getting last message ID" }}
		}

		err = srv.TelegramDeleteMessage(ctx, requestData.Actor.ID, msgID)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Error deleting message" }}
		}
	}

	if resp.DeleteCurMsg {
		err = srv.TelegramDeleteMessage(ctx, requestData.Actor.ID, requestData.MessageID)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Error deleting message" }}
		}
	}

	if requestData.CallbackID != "" {
		_, err = srv.TelegramAnswerCallback(ctx, requestData.CallbackID, notifyMsg)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Error sending answer" }}
		}
	}

	msgID := 0

	for _, tgMsg := range resp.Messages {
		switch {
		case tgMsg.InvoiceData != nil:
			msgID, err = srv.SendInvoice(ctx, requestData.ChatID, *tgMsg.InvoiceData)
			if err != nil {
				{{ .Logger.ErrorMsg "ctx" "err" "Error sending invoice" }}
				return
			}

		case tgMsg.Text != "" || len(tgMsg.Photos) > 0:
			if w.tgSrv.NeedStartHiddenMessageJob(ctx) {
				err = w.CancelHideMessage(ctx, requestData.Actor.ID, requestData.ChatID, requestData.MessageID)
				if err != nil {
					{{ .Logger.ErrorMsg "ctx" "err" "Error scheduling hide message" }}
				}
			}

			if requestData.Type == telegram.CallbackRequest && resp.UpdateCurMsg && requestData.MessageID != 0 {
				msgID, err = srv.TelegramUpdateMessageButtons(ctx, requestData, requestData.MessageID, tgMsg)
				if err != nil {
					if telegram.IsMessageEditError(err) {
						{{ .Logger.WarnMsg "ctx" "Error updating message (expected)" "Err(err)" }}
					} else {
						{{ .Logger.ErrorMsg "ctx" "err" "Error updating message" }}
					}

					err = srv.TelegramDeleteMessage(ctx, requestData.ChatID, requestData.MessageID)
					if err != nil && !telegram.IsMessageDeleteError(err) {
						{{ .Logger.WarnMsg "ctx" "Error deleting message after failed update" "Err(err)" }}
					}

					msgID, err = srv.TelegramSendMessageButtons(ctx, requestData, tgMsg)
				}
			} else {
				msgID, err = srv.TelegramSendMessageButtons(ctx, requestData, tgMsg)
			}

			if err != nil {
				{{ .Logger.ErrorMsg "ctx" "err" "Error sending message" "Interface(\"Message\", tgMsg)" }}

				origErr := err

				adm, err := srv.IsUserAdmin(ctx, requestData.Actor.ID)
				if err != nil {
					{{ .Logger.ErrorMsg "ctx" "err" "Error checking if actor is admin" }}

					return
				}

				if adm {
					_, err = srv.TelegramSendMessageButtons(ctx, requestData, telegram.Message{
						Text: "Error sending message: " + origErr.Error(),
					})
					if err != nil {
						{{ .Logger.ErrorMsg "ctx" "err" "Error sending error message to admin" }}
					}
				}

				return
			}
		default:
			{{ .Logger.ErrorMsg "ctx" "nil" "Empty message" "Interface(\"Message\", tgMsg)" }}

			continue
		}

		if tgMsg.Hidden.Action != telegram.NothingHiddenAction {
			err = w.ScheduleHideMessage(ctx, requestData.Actor.ID, requestData.ChatID, msgID, tgMsg.Hidden)
			if err != nil {
				{{ .Logger.ErrorMsg "ctx" "err" "Error scheduling hide message" }}
			}
		}

		err = w.SetLastMsgToUser(ctx, requestData.Actor.ID, msgID)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Error setting last message ID" }}

			return
		}
	}
}
