package telegram

import (
	"bytes"
	"context"
	"errors"
	"io"
	"regexp"
	"strconv"
	"strings"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/gofrs/uuid/v5"
	{{ .Logger.Import }}

	"{{ .ProjectPath }}/internal/app/constant"
)

// EmptyProducts is a default implementation of InvoiceProduct interface.
// Projects should define their own Products type with actual fields.
type EmptyProducts struct{}

func (p *EmptyProducts) Pack(w io.Writer) error {
	return nil
}

func (p *EmptyProducts) Unpack(data *bytes.Buffer) error {
	return nil
}

type UnimplementedPayment struct {
}

func (UnimplementedPayment) CheckInvoiceProducts(ctx context.Context, invoice TelegramInvoiceData, paymentType PaymentType, totalAmount int) ([]any, string, bool) {
	return nil, "unimplemented", false
}

// This function should create a payment record in the database.
// For now, we will just return nil to indicate success.
func (UnimplementedPayment) CreateTelegramPayment(ctx context.Context, idempotencyKey uuid.UUID, products InvoiceProduct, amount int, description string) error {
	return errors.New("unimplemented")
}

// This function should process the payment.
// For now, we will just return nil to indicate success.
func (UnimplementedPayment) ProcessPayment(ctx context.Context, idempotency uuid.UUID, paymentChargeID string) error {
	return errors.New("unimplemented")
}

// NewInvoiceProducts creates a new InvoiceProduct instance.
// Projects should override this to return their own Products type.
func (UnimplementedPayment) NewInvoiceProducts() InvoiceProduct {
	return &EmptyProducts{}
}

type BaseAuth struct {
}

func (s *BaseAuth) HasAdminRole(ctx context.Context, tgID int64, role string) (bool, error) {
	if tgID == 0 {
		return false, errors.New("userID is nil")
	}

	acl, exists, err := onlineconf.GetStringIfExists(ctx, onlineconf.MakePath("{{ .ProjectName }}", "bot", "admins", strconv.FormatInt(tgID, 10)))
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Failed to get admin ACL from onlineconf" }}
		return false, err
	}

	if !exists {
		return false, nil
	}

	rxNew, err := regexp.Compile(role)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Error compiling regex for full access check" }}

		return false, err
	}

	return rxNew.MatchString(acl), nil
}

func (s *BaseAuth) IsUserAdmin(ctx context.Context, tgID int64) (bool, error) {
	return s.HasAdminRole(ctx, tgID, `full`)
}

type ChatType string

const (
	PrivateChat ChatType = "private"
	GroupChat   ChatType = "group"
)

var (
	ErrUserNotFound = errors.New("admin not found")
	ErrAccessDenied  = errors.New("access denied")
	ErrInternalError = errors.New("internal error")
)

func (s *BaseAuth) TgBotAuthorization(ctx context.Context, cmd Cmd, chatType ChatType, tgID int64) error {
	if cmd.Group == (chatType == PrivateChat) {
		return ErrAccessDenied
	}

	strTgID := strconv.FormatInt(tgID, 10)

	if cmd.NeedAdminAccess {
		acl, ex, err := onlineconf.GetStringIfExists(ctx, onlineconf.MakePath(constant.ServiceName, "bot", "admins", strTgID))
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Get onlineconf admin" }}

			return ErrInternalError
		}

		if ex {
			// Any admin has access
			if len(cmd.AdminRole) == 0 {
				return nil
			}

			rxStr := `(^|,)(role:(`

			quotedRoles := []string{}
			for _, r := range cmd.AdminRole {
				quotedRoles = append(quotedRoles, regexp.QuoteMeta(string(r)))
			}

			rxStr += strings.Join(quotedRoles, "|") + `|root)|` + regexp.QuoteMeta(cmd.Name.String()) + `)(,|$)`

			rxNew, err := regexp.Compile(rxStr)
			if err != nil {
				{{ .Logger.ErrorMsg "ctx" "err" "Error compiling regex" }}

				return ErrInternalError
			}

			// Check specific role or command access
			if rxNew.MatchString(acl) {
				return nil
			}
		}

		return ErrAccessDenied
	}

	paths := []string{
		onlineconf.MakePath(constant.ServiceName, "bot", "users"),
		onlineconf.MakePath(constant.ServiceName, "bot", "users", strTgID),
	}

	for _, param := range paths {
		acl, ex, err := onlineconf.GetStringIfExists(ctx, param)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Get onlineconf admin" }}

			return ErrInternalError
		}

		if !ex {
			continue
		}

		rxNew, err := regexp.Compile(`(^|,)(full|` + regexp.QuoteMeta(cmd.Name.String()) + `)(,|$)`)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Error compiling regex" }}

			return ErrInternalError
		}

		if rxNew.MatchString(acl) {
			return nil
		}
	}

	return ErrAccessDenied
}