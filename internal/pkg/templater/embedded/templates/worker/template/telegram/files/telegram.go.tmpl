package {{ .Worker.Name }}

import (
	"context"
	"time"
	"strings"
	"runtime/debug"
	"errors"

	{{ .Logger.Import }}
	"github.com/prometheus/client_golang/prometheus"
	tgbotapi "github.com/OvyFlash/telegram-bot-api"
	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"golang.org/x/sync/errgroup"

	"{{ .ProjectPath }}/pkg/app/daemon"
	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
	"{{ .ProjectPath }}/pkg/drivers/telegram"
	"{{ .ProjectPath }}/internal/app/constant"	
	"{{ .ProjectPath }}/internal/pkg/service"
)

type Worker struct {
	EmptyCommands
	telegram.UnimplementedUpdateHandler
	telegram.UnimplementedAdminStatusHandler
	daemon.EmptyWorker
	Srv ds.IService
	tgSrv TelegramUpdateWorker 
	jobState any
}

type EmptyCommands struct{}

func (e *EmptyCommands) GetCommandList() []telegram.CommandName {
	return []telegram.CommandName{}
}

type TelegramUpdateWorker interface {
	NeedStartHiddenMessageJob(ctx context.Context) bool
	GetUpdateChannel(ctx context.Context) tgbotapi.UpdatesChannel
	StopChannel(ctx context.Context)
}

const (
	nameFieldLogger = "Name"
	WorkerName      = "{{ .Worker.Name }}"
)

var (
	ErrServiceType = errors.New("service type is not TelegramUpdateWorker")
)

func Create() *Worker {
    return &Worker{}
}

func (w *Worker) Name() string {
	return WorkerName
}

func (w *Worker) Init(ctx context.Context, serviceName, _ string, metrics *prometheus.Registry, srv ds.IService) error {
	w.Srv = srv

	var err error

	w.tgSrv, err = w.GetTelegramSrv()
	if err != nil {
		return err
	}

	return nil
}

func GetConfigPath(key ...string) string{
	components := []string{constant.ServiceName, "worker", WorkerName}
	components = append(components, key...)

	return onlineconf.MakePath(components...)
}

func (w *Worker) JobStarter(ctx context.Context, update tgbotapi.Update) (error) {
	ctxJob, cancel := reqctx.CreateContext(ctx, ctx, GetConfigPath(), "job")
	{{ .Logger.UpdateContext "ctxJob" "Int(\"updateID\", update.UpdateID)" "Str(nameFieldLogger, WorkerName)" }}

	pi := reqctx.RequestProcessInfo{}
	ctxJob = reqctx.SetProcessInfo(ctxJob, &pi)

	defer func() {
		err := recover()
		if err != nil {
			{{ .Logger.ErrorMsg "ctxJob" "errors.New(\"panic catch\")" "panic" "Interface(\"panic error\", err)" "Str(\"Stack\", strings.ReplaceAll(strings.ReplaceAll(string(debug.Stack()), \"\\n\\t/\", \" --> /\"), \"\\n\", \" => \"))" }}
		}

		cancel()
	}()

	srv, err := w.GetEmptySrv()
	if err != nil {
		zlog.Ctx(ctxJob).Error().Err(err).Msg("Failed to get service")

		return err
	}

	startTime := time.Now()

	switch {
	case update.PreCheckoutQuery != nil:
		str := ""

		pi.Command = "PreCheckout"

		ctxJob, err = w.PreCheckout(ctxJob, update.PreCheckoutQuery)
		if err != nil {
			str = err.Error()
		}

		err = srv.TelegramAnswerPreCheckout(ctx, update.PreCheckoutQuery.ID, str)
	case update.Message != nil && update.Message.SuccessfulPayment != nil:
		pi.Command = "Purchase"

		ctxJob, err = w.Purchase(ctxJob, update.Message)
	case update.Message != nil && update.Message.Document != nil:
		ctxJob, err = w.DocumentMessage(ctxJob, update.Message)
	case update.Message != nil && update.Message.Text != "":
		ctxJob, err = w.TextMessage(ctxJob, update.Message)
	case update.CallbackQuery != nil:
		ctxJob, err = w.CallbackQuery(ctxJob, update.CallbackQuery)
	default:
		zlog.Ctx(ctxJob).Info().Interface("Update", update).Msg("Skipping update")
		
		err = telegram.ErrUnsupportedHandler
	}

	status := "Ok"
	if err != nil {
		status = err.Error()
	}

	srv.BotHitInfo(ctxJob, pi, status, pi.ContentLength, time.Since(startTime))

	return err
}

// Run - start worker
func (w *Worker) Run(ctx context.Context, errGr *errgroup.Group) {
	// initialization worker
	errGr.Go(func() error {
		{{ .Logger.InfoMsg "ctx" "Run worker" "Str(nameFieldLogger, WorkerName)" }}

	JOB:
		for {
			select {
			case update := <- w.tgSrv.GetUpdateChannel(ctx):
				{{ .Logger.InfoMsg "ctx" "worker get update" "Int(\"updateID\", update.UpdateID)" "Interface(\"update\", update)" "Str(nameFieldLogger, WorkerName)" }}

				err := w.JobStarter(ctx, update)
				if err != nil {
					if errors.Is(err, telegram.ErrUnimplementedHandler) {
						{{ .Logger.InfoMsg "ctx" "unimplemented. skip" "Str(nameFieldLogger, WorkerName)" }}

						continue
					}

					if errors.Is(err, telegram.ErrUnsupportedHandler) {
						{{ .Logger.InfoMsg "ctx" "unsupported. skip" "Str(nameFieldLogger, WorkerName)" }}

						continue
					}

					{{ .Logger.ErrorMsg "ctx" "err" "worker error" "Str(nameFieldLogger, WorkerName)" }}
				}

			case <-ctx.Done():
				break JOB
			}
		}

		{{ .Logger.InfoMsg "ctx" "worker stopped" "Str(nameFieldLogger, WorkerName)" }}

		return nil
	})

	if w.tgSrv.NeedStartHiddenMessageJob(ctx) {
		errGr.Go(func() error {
			zlog.Ctx(ctx).Info().Str(nameFieldLogger, WorkerName).Msg("Run hidden message job")

			timerDuration := time.Second * 1
			iterNum := 1

			ErrorTimeout := time.Minute

		HIDDEN_JOB:
			for {
				timer := time.NewTimer(timerDuration)

				timerDuration = ErrorTimeout

				select {
				case <-timer.C:
					iterNum++
					if iterNum%100 == 0 {
						zlog.Ctx(ctx).Info().Int("iterNum", iterNum).Str(nameFieldLogger, WorkerName).Msg("worker iteration")
					}

					hiddenMessages, err := w.GetHiddenMessages(ctx)
					if err != nil {
						zlog.Ctx(ctx).Error().Str(nameFieldLogger, WorkerName).Err(err).Msg("Error get hidden message")

						continue
					}

					for _, hm := range hiddenMessages {
						ctx, cancel := reqctx.CreateContext(ctx, ctx, GetConfigPath(), "job")
						zlog.Ctx(ctx).UpdateContext(func(c zlog.Context) zlog.Context {
							return c.Int("hiddenMsgID", hm.MsgID).Str(nameFieldLogger, WorkerName)
						})

						defer func() {
							err := recover()
							if err != nil {
								zlog.Ctx(ctx).Error().
									Interface("panic error", err).
									Str("Stack", strings.ReplaceAll(strings.ReplaceAll(string(debug.Stack()), "\n\t/", " --> /"), "\n", " => ")).
									Err(errors.New("panic catch")).Msg("panic")
							}

							cancel()
						}()

						srv, err := w.GetEmptySrv()
						if err != nil {
							zlog.Ctx(ctx).Error().Err(err).Msg("Failed to get service")

							continue
						}

						switch hm.Action {
						case telegram.DeleteHiddenAction:
							timerDuration = time.Second

							err := srv.TelegramDeleteMessage(ctx, hm.ChatID, hm.MsgID)
							if err != nil {
								zlog.Ctx(ctx).Error().Err(err).Msg("Can't delete hidden messge")

								err := w.DoneHiddenMessages(ctx, hm)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't mark hidden message as done")
								}

								continue
							}
						case telegram.UpdateHiddenAction:
							c, ex := cmdMaps[hm.CmdName]
							if !ex {
								zlog.Ctx(ctx).Info().Str("Cmd", string(hm.CmdName)).Msg("Unknown command")

								err = srv.TelegramDeleteMessage(ctx, hm.ChatID, hm.MsgID)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't delete hidden messge")
								}

								err = w.DoneHiddenMessages(ctx, hm)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't mark hidden message as done")
								}

								timerDuration = time.Second

								continue
							}

							requestData := telegram.RequestData{
								Type:   telegram.TextRequest,
								ChatID: hm.ChatID,
								Actor: telegram.Actor{
									ID: hm.UserID,
								},
								MessageID: hm.MsgID,
								Commands:  w.getCommandList(),
								Command:   c,
							}

							_, hdl, err := w.GetServiceAndHandler(ctx, requestData)
							if err != nil {
								zlog.Ctx(ctx).Error().Err(err).Msg("Error getting handler")

								continue
							}

							ctx, aclErr := hdl.Authorization(ctx, requestData, hm.Params)
							if aclErr != nil {
								zlog.Ctx(ctx).Error().Err(aclErr).Msg("Authorization error for hidden message")

								err = srv.TelegramDeleteMessage(ctx, hm.ChatID, hm.MsgID)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't delete hidden messge")
								}
								err = w.DoneHiddenMessages(ctx, hm)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't mark hidden message as done")
								}

								timerDuration = time.Second

								continue
							}

							aclErr = w.Authorization(ctx, hdl.Rd)
							if aclErr != nil {
								zlog.Ctx(ctx).Error().Err(aclErr).Msg("Authorization error for hidden message")

								err = srv.TelegramDeleteMessage(ctx, hm.ChatID, hm.MsgID)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't delete hidden messge")
								}

								err = w.DoneHiddenMessages(ctx, hm)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't mark hidden message as done")
								}

								timerDuration = time.Second

								continue
							}

							resp, err := c.Handler(ctx, hdl, hm.Params)
							if err != nil {
								zlog.Ctx(ctx).Error().Err(err).Msg("Error handling hidden message")

								continue
							}

							if resp.InternalRedirect != nil {
								zlog.Ctx(ctx).Error().Str("Cmd", resp.InternalRedirect.Cmd.String()).Msg("Internal redirect not supported for hidden message")

								err = srv.TelegramDeleteMessage(ctx, hm.ChatID, hm.MsgID)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't delete hidden messge")
								}

								err = w.DoneHiddenMessages(ctx, hm)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't mark hidden message as done")
								}

								timerDuration = time.Second

								continue
							}

							if len(resp.Messages) == 0 {
								zlog.Ctx(ctx).Error().Msg("No messages in response for hidden message")

								err = srv.TelegramDeleteMessage(ctx, hm.ChatID, hm.MsgID)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't delete hidden messge")
								}

								err = w.DoneHiddenMessages(ctx, hm)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't mark hidden message as done")
								}

								timerDuration = time.Second

								continue
							}

							timerDuration = time.Second

							_, err = srv.TelegramUpdateMessageButtons(ctx, hm.ChatID, hm.MsgID, resp.Messages[0])
							if err != nil {
								zlog.Ctx(ctx).Error().Err(err).Msg("Can't update hidden message")

								err = srv.TelegramDeleteMessage(ctx, hm.ChatID, hm.MsgID)
								if err != nil {
									zlog.Ctx(ctx).Error().Err(err).Msg("Can't delete hidden messge")
								}
							}

							err = w.DoneHiddenMessages(ctx, hm)
							if err != nil {
								zlog.Ctx(ctx).Error().Err(err).Msg("Can't mark hidden message as done")
							}

							continue

						case telegram.NothingHiddenAction:
							timerDuration = time.Second

						default:
							zlog.Ctx(ctx).Error().Str("Action", string(hm.Action)).Msg("Unknown hidden action")
						}
					}

				case <-ctx.Done():
					break HIDDEN_JOB
				}
			}

			zlog.Ctx(ctx).Info().Str(nameFieldLogger, WorkerName).Msg("hidden message job stopped")

			return nil
		})
	}
}

// Shutdown shutting down telegram worker
func (w *Worker) Shutdown(_ context.Context) error {
	return nil
}

// GracefulStop do graceful stop telegram worker
func (w *Worker) GracefulStop(ctx context.Context) (<-chan struct{}, error) {
	{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "Str(nameFieldLogger, WorkerName)" }}
	w.tgSrv.StopChannel(ctx)
	stopped := make(chan struct{})

	go func() {
		{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "Str(nameFieldLogger, WorkerName)" }}
		// wait for all jobs to finish
		// or timeout
		c := time.NewTicker(time.Millisecond * 100)
		{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "Str(nameFieldLogger, WorkerName)" }}
		for {
			select {
			case <-c.C:
				if len(w.tgSrv.GetUpdateChannel(ctx)) == 0 {
					{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "Str(nameFieldLogger, WorkerName)" }}

					close(stopped)
					
					return
				}
			}
		}
	}()

	return stopped, nil
}

func (w *Worker) GetTelegramSrv() (TelegramUpdateWorker, error) {
	srv, ok := w.Srv.(TelegramUpdateWorker)
	if !ok {
		return nil, ErrServiceType
	}

	return srv, nil
}

func (w *Worker) GetEmptySrv() (*service.EmptyService, error) {
	srv, ok := w.Srv.(*service.EmptyService)
	if !ok {
		return nil, ErrServiceType
	}

	return srv, nil
}