package {{ .Worker.Name }}

import (
	"context"
	"time"
	"strings"
	"runtime/debug"
	"errors"

	{{ .Logger.Import }}
	"github.com/prometheus/client_golang/prometheus"
	tgbotapi "github.com/OvyFlash/telegram-bot-api"
	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"golang.org/x/sync/errgroup"

	"{{ .ProjectPath }}/pkg/app/daemon"
	"github.com/Educentr/go-project-starter-runtime/pkg/app/metrics"
	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
{{ if ne (.Logger.FilesToGenerate) "logrus" }}	"github.com/Educentr/go-project-starter-runtime/pkg/logger"
{{ end }}	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
	"{{ .ProjectPath }}/pkg/drivers/telegram"
	"{{ .ProjectPath }}/internal/app/constant"
	"{{ .ProjectPath }}/internal/pkg/service"
)

type Worker struct {
	EmptyCommands
	telegram.UnimplementedUpdateHandler
	telegram.UnimplementedAdminStatusHandler
	daemon.EmptyWorker
	Srv ds.IService
	tgSrv TelegramUpdateWorker
	jobState any
	tgMetrics *metrics.TelegramMetrics
}

type EmptyCommands struct{}

func (e *EmptyCommands) GetCommandList() []telegram.Cmd {
	return []telegram.Cmd{}
}

type TelegramUpdateWorker interface {
	NeedStartHiddenMessageJob(ctx context.Context) bool
	GetUpdateChannel(ctx context.Context) tgbotapi.UpdatesChannel
	StopChannel(ctx context.Context)
}

const (
	nameFieldLogger = "Name"
	WorkerName      = "{{ .Worker.Name }}"
)

var (
	ErrServiceType = errors.New("service type is not TelegramUpdateWorker")
)

func Create() *Worker {
    return &Worker{}
}

func (w *Worker) Name() string {
	return WorkerName
}

func (w *Worker) Init(ctx context.Context, serviceName, _ string, metricsRegistry *prometheus.Registry, srv ds.IService) error {
	w.Srv = srv

	// Initialize Telegram metrics if registry provided
	if metricsRegistry != nil {
		nameForMetric := strings.ReplaceAll(serviceName, "-", "_")
		w.tgMetrics = metrics.NewTelegramMetrics(metricsRegistry, nameForMetric)
	}

	var err error

	w.tgSrv, err = w.GetTelegramSrv()
	if err != nil {
		return err
	}

	return nil
}

func GetConfigPath(key ...string) string{
	components := []string{constant.ServiceName, "worker", WorkerName}
	components = append(components, key...)

	return onlineconf.MakePath(components...)
}

func (w *Worker) getUpdateType(update tgbotapi.Update) string {
	switch {
	case update.Message != nil && update.Message.Text != "":
		return "text_message"
	case update.Message != nil && update.Message.Document != nil:
		return "document"
	case update.CallbackQuery != nil:
		return "callback"
	case update.PreCheckoutQuery != nil:
		return "pre_checkout"
	case update.Message != nil && update.Message.SuccessfulPayment != nil:
		return "payment"
	default:
		return "other"
	}
}

func (w *Worker) JobStarter(ctx context.Context, update tgbotapi.Update) (error) {
	ocPrefix := GetConfigPath()

	defaultTimeout, err := onlineconf.GetDuration(ctx, onlineconf.MakePath(ocPrefix, "default", "timeout"), 0)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "error getting default job timeout" "str::$nameFieldLogger::WorkerName" }}
	}
	jobTimeout, err := onlineconf.GetDuration(ctx, onlineconf.MakePath(ocPrefix, "job", "timeout"), defaultTimeout)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "error getting job timeout" "str::$nameFieldLogger::WorkerName" }}
	}

	ctxJob, cancel, err := reqctx.CreateContextWithTimeout(ctx, ctx, jobTimeout)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Failed to create job context" "str::$nameFieldLogger::WorkerName" }}
		return err
	}
	{{ .Logger.ReWrap "ctx" "ctxJob" "ocPrefix" "\"job\"" }}
	{{ .Logger.UpdateContext "ctxJob" "int::updateID::update.UpdateID" "str::$nameFieldLogger::WorkerName" }}

	pi := reqctx.RequestProcessInfo{}
	ctxJob = reqctx.SetProcessInfo(ctxJob, &pi)

	// Record update received
	if w.tgMetrics != nil {
		updateType := w.getUpdateType(update)
		w.tgMetrics.UpdatesReceivedTotal.WithLabelValues(updateType).Inc()
	}

	defer func() {
		err := recover()
		if err != nil {
			{{ .Logger.ErrorMsg "ctxJob" "errors.New(\"panic catch\")" "panic" "any::panic error::err" "str::Stack::strings.ReplaceAll(strings.ReplaceAll(string(debug.Stack()), \"\\n\\t/\", \" --> /\"), \"\\n\", \" => \")" }}
		}

		cancel()
	}()

	srv, err := w.GetEmptySrv()
	if err != nil {
		{{ .Logger.ErrorMsg "ctxJob" "err" "Failed to get service" }}

		return err
	}

	startTime := time.Now()

	switch {
	case update.PreCheckoutQuery != nil:
		str := ""

		pi.Command = "PreCheckout"

		ctxJob, err = w.PreCheckout(ctxJob, update.PreCheckoutQuery)
		if err != nil {
			str = err.Error()
		}

		err = srv.TelegramAnswerPreCheckout(ctx, update.PreCheckoutQuery.ID, str)
	case update.Message != nil && update.Message.SuccessfulPayment != nil:
		pi.Command = "Purchase"

		ctxJob, err = w.Purchase(ctxJob, update.Message)

		// Record payment metric
		if w.tgMetrics != nil {
			paymentStatus := "success"
			if err != nil {
				paymentStatus = "failed"
			}
			w.tgMetrics.PaymentsTotal.WithLabelValues(paymentStatus).Inc()
		}
	case update.Message != nil && update.Message.Document != nil:
		ctxJob, err = w.DocumentMessage(ctxJob, update.Message)
	case update.Message != nil && update.Message.Text != "":
		ctxJob, err = w.TextMessage(ctxJob, update.Message)
	case update.CallbackQuery != nil:
		ctxJob, err = w.CallbackQuery(ctxJob, update.CallbackQuery)
	default:
		{{ .Logger.InfoMsg "ctxJob" "Skipping update" "any::Update::update" }}
		
		err = telegram.ErrUnsupportedHandler
	}

	status := "Ok"
	if err != nil {
		status = err.Error()

		// Record error metric
		if w.tgMetrics != nil {
			errorType := "handler_error"
			if errors.Is(err, telegram.ErrUnsupportedHandler) {
				errorType = "unsupported"
			} else if errors.Is(err, telegram.ErrUnimplementedHandler) {
				errorType = "unimplemented"
			}
			w.tgMetrics.ErrorsTotal.WithLabelValues(errorType).Inc()
		}
	}

	// Record command metrics
	if w.tgMetrics != nil {
		w.tgMetrics.CommandsTotal.WithLabelValues(pi.Command, status).Inc()
		w.tgMetrics.CommandDuration.WithLabelValues(pi.Command).Observe(time.Since(startTime).Seconds())
	}

	srv.BotHitInfo(ctxJob, pi, status, pi.ContentLength, time.Since(startTime))

	return err
}

// Run - start worker
func (w *Worker) Run(ctx context.Context, errGr *errgroup.Group) {
	// initialization worker
	errGr.Go(func() error {
		{{ .Logger.InfoMsg "ctx" "Run worker" "str::$nameFieldLogger::WorkerName" }}

	JOB:
		for {
			select {
			case update := <- w.tgSrv.GetUpdateChannel(ctx):
				{{ .Logger.InfoMsg "ctx" "worker get update" "int::updateID::update.UpdateID" "any::update::update" "str::$nameFieldLogger::WorkerName" }}

				err := w.JobStarter(ctx, update)
				if err != nil {
					if errors.Is(err, telegram.ErrUnimplementedHandler) {
						{{ .Logger.InfoMsg "ctx" "unimplemented. skip" "str::$nameFieldLogger::WorkerName" }}

						continue
					}

					if errors.Is(err, telegram.ErrUnsupportedHandler) {
						{{ .Logger.InfoMsg "ctx" "unsupported. skip" "str::$nameFieldLogger::WorkerName" }}

						continue
					}

					{{ .Logger.ErrorMsg "ctx" "err" "worker error" "str::$nameFieldLogger::WorkerName" }}
				}

			case <-ctx.Done():
				break JOB
			}
		}

		{{ .Logger.InfoMsg "ctx" "worker stopped" "str::$nameFieldLogger::WorkerName" }}

		return nil
	})

	if w.tgSrv.NeedStartHiddenMessageJob(ctx) {
		errGr.Go(func() error {
			{{ .Logger.InfoMsg "ctx" "Run hidden message job" "str::$nameFieldLogger::WorkerName" }}

			timerDuration := time.Second * 1
			iterNum := 1

			ErrorTimeout := time.Minute

		HIDDEN_JOB:
			for {
				timer := time.NewTimer(timerDuration)

				timerDuration = ErrorTimeout

				select {
				case <-timer.C:
					iterNum++
					if iterNum%100 == 0 {
						{{ .Logger.InfoMsg "ctx" "worker iteration" "int::iterNum::iterNum" "str::$nameFieldLogger::WorkerName" }}
					}

					hiddenMessages, err := w.GetHiddenMessages(ctx)
					if err != nil {
						{{ .Logger.ErrorMsg "ctx" "err" "Error get hidden message" "str::$nameFieldLogger::WorkerName" }}

						continue
					}

					// Update hidden messages queue gauge
					if w.tgMetrics != nil {
						w.tgMetrics.HiddenMessagesQueue.WithLabelValues("pending").Set(float64(len(hiddenMessages)))
					}

					for _, hm := range hiddenMessages {
						ocPrefix := GetConfigPath()

						defaultTimeout, err := onlineconf.GetDuration(ctx, onlineconf.MakePath(ocPrefix, "default", "timeout"), 0)
						if err != nil {
							{{ .Logger.ErrorMsg "ctx" "err" "error getting default job timeout" "str::$nameFieldLogger::WorkerName" }}
						}
						hmTimeout, err := onlineconf.GetDuration(ctx, onlineconf.MakePath(ocPrefix, "job", "timeout"), defaultTimeout)
						if err != nil {
							{{ .Logger.ErrorMsg "ctx" "err" "error getting job timeout" "str::$nameFieldLogger::WorkerName" }}
						}

						hmCtx, cancel, err := reqctx.CreateContextWithTimeout(ctx, ctx, hmTimeout)
						if err != nil {
							{{ .Logger.ErrorMsg "ctx" "err" "Failed to create context for hidden message" "str::$nameFieldLogger::WorkerName" }}
							continue
						}
						{{ .Logger.ReWrap "ctx" "hmCtx" "ocPrefix" "\"job\"" }}
						{{ .Logger.UpdateContext "hmCtx" "int::hiddenMsgID::hm.MsgID" "str::$nameFieldLogger::WorkerName" }}

						defer func() {
							err := recover()
							if err != nil {
								{{ .Logger.ErrorMsg "hmCtx" "errors.New(\"panic catch\")" "panic" "any::panic error::err" "str::Stack::strings.ReplaceAll(strings.ReplaceAll(string(debug.Stack()), \"\\n\\t/\", \" --> /\"), \"\\n\", \" => \")" }}
							}

							cancel()
						}()

						srv, err := w.GetEmptySrv()
						if err != nil {
							{{ .Logger.ErrorMsg "hmCtx" "err" "Failed to get service" }}

							continue
						}

						switch hm.Action {
						case telegram.DeleteHiddenAction:
							timerDuration = time.Second

							err := srv.TelegramDeleteMessage(hmCtx, hm.ChatID, hm.MsgID)
							if err != nil {
								{{ .Logger.ErrorMsg "hmCtx" "err" "Can't delete hidden messge" }}

								err := w.DoneHiddenMessages(hmCtx, hm)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't mark hidden message as done" }}
								}

								continue
							}
						case telegram.UpdateHiddenAction:
							c, ex := cmdMaps[hm.CmdName]
							if !ex {
								{{ .Logger.InfoMsg "hmCtx" "Unknown command" "str::Cmd::string(hm.CmdName)" }}

								err = srv.TelegramDeleteMessage(hmCtx, hm.ChatID, hm.MsgID)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't delete hidden messge" }}
								}

								err = w.DoneHiddenMessages(hmCtx, hm)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't mark hidden message as done" }}
								}

								timerDuration = time.Second

								continue
							}

							requestData := telegram.RequestData{
								Type:   telegram.TextRequest,
								ChatID: hm.ChatID,
								Actor: telegram.Actor{
									ID: hm.UserID,
								},
								MessageID: hm.MsgID,
								Commands:  w.GetCommandList(),
								Command:   c,
							}

							_, hdl, err := w.GetServiceAndHandler(hmCtx, requestData)
							if err != nil {
								{{ .Logger.ErrorMsg "hmCtx" "err" "Error getting handler" }}

								continue
							}

							hmCtx, aclErr := hdl.Authorization(hmCtx, requestData, hm.Params)
							if aclErr != nil {
								{{ .Logger.ErrorMsg "hmCtx" "aclErr" "Authorization error for hidden message" }}

								err = srv.TelegramDeleteMessage(hmCtx, hm.ChatID, hm.MsgID)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't delete hidden messge" }}
								}
								err = w.DoneHiddenMessages(hmCtx, hm)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't mark hidden message as done" }}
								}

								timerDuration = time.Second

								continue
							}

							aclErr = w.Authorization(hmCtx, hdl.Rd)
							if aclErr != nil {
								{{ .Logger.ErrorMsg "hmCtx" "aclErr" "Authorization error for hidden message" }}

								err = srv.TelegramDeleteMessage(hmCtx, hm.ChatID, hm.MsgID)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't delete hidden messge" }}
								}

								err = w.DoneHiddenMessages(hmCtx, hm)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't mark hidden message as done" }}
								}

								timerDuration = time.Second

								continue
							}

							resp, err := c.Handler(hmCtx, hdl, hm.Params)
							if err != nil {
								{{ .Logger.ErrorMsg "hmCtx" "err" "Error handling hidden message" }}

								continue
							}

							if resp.InternalRedirect != nil {
								{{ .Logger.ErrorMsg "hmCtx" "nil" "Internal redirect not supported for hidden message" "str::Cmd::resp.InternalRedirect.Cmd.String()" }}

								err = srv.TelegramDeleteMessage(hmCtx, hm.ChatID, hm.MsgID)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't delete hidden messge" }}
								}

								err = w.DoneHiddenMessages(hmCtx, hm)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't mark hidden message as done" }}
								}

								timerDuration = time.Second

								continue
							}

							if len(resp.Messages) == 0 {
								{{ .Logger.ErrorMsg "hmCtx" "nil" "No messages in response for hidden message" }}

								err = srv.TelegramDeleteMessage(hmCtx, hm.ChatID, hm.MsgID)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't delete hidden messge" }}
								}

								err = w.DoneHiddenMessages(hmCtx, hm)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't mark hidden message as done" }}
								}

								timerDuration = time.Second

								continue
							}

							timerDuration = time.Second

							hmRequestData := telegram.RequestData{
								Type:      telegram.HiddenMessageRequest,
								ChatID:    hm.ChatID,
								Actor:     telegram.Actor{ID: hm.UserID},
								MessageID: hm.MsgID,
								Commands:  w.GetCommandList(),
							}
							_, err = srv.TelegramUpdateMessageButtons(hmCtx, hmRequestData, hm.MsgID, resp.Messages[0])
							if err != nil {
								{{ .Logger.ErrorMsg "hmCtx" "err" "Can't update hidden message" }}

								err = srv.TelegramDeleteMessage(hmCtx, hm.ChatID, hm.MsgID)
								if err != nil {
									{{ .Logger.ErrorMsg "hmCtx" "err" "Can't delete hidden messge" }}
								}
							}

							err = w.DoneHiddenMessages(hmCtx, hm)
							if err != nil {
								{{ .Logger.ErrorMsg "hmCtx" "err" "Can't mark hidden message as done" }}
							}

							continue

						case telegram.NothingHiddenAction:
							timerDuration = time.Second

						default:
							{{ .Logger.ErrorMsg "hmCtx" "nil" "Unknown hidden action" "str::Action::string(hm.Action)" }}
						}
					}

				case <-ctx.Done():
					break HIDDEN_JOB
				}
			}

			{{ .Logger.InfoMsg "ctx" "hidden message job stopped" "str::$nameFieldLogger::WorkerName" }}

			return nil
		})
	}
}

// Shutdown shutting down telegram worker
func (w *Worker) Shutdown(_ context.Context) error {
	return nil
}

// GracefulStop do graceful stop telegram worker
func (w *Worker) GracefulStop(ctx context.Context) (<-chan struct{}, error) {
	{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "str::$nameFieldLogger::WorkerName" }}
	w.tgSrv.StopChannel(ctx)
	stopped := make(chan struct{})

	go func() {
		{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "str::$nameFieldLogger::WorkerName" }}
		// wait for all jobs to finish
		// or timeout
		c := time.NewTicker(time.Millisecond * 100)
		{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "str::$nameFieldLogger::WorkerName" }}
		for {
			select {
			case <-c.C:
				if len(w.tgSrv.GetUpdateChannel(ctx)) == 0 {
					{{ .Logger.InfoMsg "ctx" "GracefulStop telegram worker" "str::$nameFieldLogger::WorkerName" }}

					close(stopped)
					
					return
				}
			}
		}
	}()

	return stopped, nil
}

func (w *Worker) GetTelegramSrv() (TelegramUpdateWorker, error) {
	srv, ok := w.Srv.(TelegramUpdateWorker)
	if !ok {
		return nil, ErrServiceType
	}

	return srv, nil
}

func (w *Worker) GetEmptySrv() (*service.EmptyService, error) {
	srv, ok := w.Srv.(*service.EmptyService)
	if !ok {
		return nil, ErrServiceType
	}

	return srv, nil
}