package telegrambot

import (
	"context"
	"strings"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	tgbotapi "github.com/OvyFlash/telegram-bot-api"
	"github.com/pkg/errors"
	{{ .Logger.Import }}

	"{{ .ProjectPath }}/internal/app/constant"
	"{{ .ProjectPath }}/internal/app/worker/telegrambot/handler"
	"{{ .ProjectPath }}/internal/pkg/ds"
	"{{ .ProjectPath }}/internal/pkg/service"
	"{{ .ProjectPath }}/pkg/drivers/telegram"
	"{{ .ProjectPath }}/pkg/reqctx"
	apptg "{{ .ProjectPath }}/pkg/app/telegram"
)

// ToDo бесполезная функция надо от неё избавиться и handler вузде создавать по месту а сервис получать как w.GetEmptySrv()
func (w *Worker) GetServiceAndHandler(ctx context.Context) (*service.EmptyService, *handler.Handler, error) {
	srv, err := w.GetEmptySrv()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Internal error. Can't get service")
	}

	return srv, handler.NewHandler(srv), nil
}

func (w *Worker) PreCheckout(ctx context.Context, preCheckoutQuery *tgbotapi.PreCheckoutQuery) (context.Context, error) {
	if preCheckoutQuery == nil {
		return ctx, errors.New("preCheckout is empty")
	}

	tgActor := telegram.Actor{
		ID:           preCheckoutQuery.From.ID,
		Username:     preCheckoutQuery.From.UserName,
		FirstName:    preCheckoutQuery.From.FirstName,
		LastName:     preCheckoutQuery.From.LastName,
		LanguageCode: preCheckoutQuery.From.LanguageCode,
	}

	ctx, err := reqctx.SetTgActor(ctx, &tgActor)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error setting request context")

		return ctx, errors.Wrap(err, "Internal error")
	}

	srv, hdl, err := w.GetServiceAndHandler(ctx)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error getting service and handler")

		return ctx, errors.Wrap(err, "Internal error")
	}

	ctx, aclErr := hdl.Authorization(ctx, "PreCheckout", "")
	if aclErr != nil {
		w.HandleAuthError(ctx, PreCheckoutRequest, aclErr)

		return ctx, errors.Wrap(err, "Internal error")
	}

	invoice := telegram.TelegramInvoiceData{
		Products: &ds.Products{},
	}

	err = telegram.UnpackInvoiceData(ctx, &invoice, preCheckoutQuery.InvoicePayload)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("error unpacking invoice data")

		return ctx, errors.New("Invalid invoice")
	}

	desc, ok := srv.CheckInvoiceProducts(ctx, invoice, telegram.PaymentTypeStars, preCheckoutQuery.TotalAmount)
	if !ok {
		zlog.Ctx(ctx).Error().Msg("invalid invoice products")

		return ctx, errors.New("Invalid invoice")
	}
	
	if tgActor.ID != invoice.UserID {
		zlog.Ctx(ctx).Error().Msg("userID mismatch")

		return ctx, errors.New("User ID mismatch")
	}

	err = srv.CreateTelegramPayment(ctx, invoice.IdempotencyKey, invoice.Products, preCheckoutQuery.TotalAmount, desc)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("error inserting payment")

		return ctx, ErrInternalError
	}

	return ctx, nil
}

func (w *Worker) Purchase(ctx context.Context, message *tgbotapi.Message) (context.Context, error) {
	tgActor := telegram.Actor{
		ID:           message.From.ID,
		Username:     message.From.UserName,
		FirstName:    message.From.FirstName,
		LastName:     message.From.LastName,
		LanguageCode: message.From.LanguageCode,
	}

	ctx, err := reqctx.SetMsgContext(ctx, &tgActor, message.Chat.ID, message.MessageID, "")
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error setting request context")

		return ctx, errors.Wrap(err, "Internal error")
	}

	srv, hdl, err := w.GetServiceAndHandler(ctx)
	if err != nil {
		return ctx, errors.Wrap(err, "Internal error. Can't get service")
	}

	ctx, aclErr := hdl.Authorization(ctx, "Purchase", "")
	if aclErr != nil {
		w.HandleAuthError(ctx, PurchaseRequest, aclErr)

		return ctx, errors.Wrap(err, "Internal error")
	}

	devstand, err := onlineconf.GetBool(ctx, onlineconf.MakePath(constant.ServiceName, "devstand"), false)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Unexpected error from onlineconf")
	}

	invoice := telegram.TelegramInvoiceData{
		Products: &ds.Products{},
	}

	err = telegram.UnpackInvoiceData(ctx, &invoice, message.SuccessfulPayment.InvoicePayload)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("error unpacking invoice data")

		return ctx, errors.New("Invalid invoice")
	}

	defer func() {
		if devstand {
			err = srv.TelegramRefundPayment(ctx, message.From.ID, message.SuccessfulPayment.TelegramPaymentChargeID)
			if err != nil {
				zlog.Ctx(ctx).Error().Err(err).Msg("Error refunding payment")
			}
		}
	}()

	resp, err := hdl.ProcessPayment(ctx, invoice.IdempotencyKey, message.SuccessfulPayment)
	w.postProcessRequest(ctx, PurchaseRequest, resp, err)
		
	return ctx, nil
}

func (w *Worker) CallbackQuery(ctx context.Context, callback *tgbotapi.CallbackQuery) (context.Context, error) {
	zlog.Ctx(ctx).Info().Interface("text", callback).Msg("Text callback received")

	data := strings.SplitN(callback.Data[1:], ":", 2)

	params := ""
	if len(data) > 1 {
		params = data[1]
	}

	tgActor := telegram.Actor{
		ID:           callback.From.ID,
		Username:     callback.From.UserName,
		FirstName:    callback.From.FirstName,
		LastName:     callback.From.LastName,
		LanguageCode: callback.From.LanguageCode,
	}

	ctx, err := reqctx.SetMsgContext(ctx, &tgActor, callback.Message.Chat.ID, callback.Message.MessageID, callback.ID)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error setting request context")

		return ctx, errors.Wrap(err, "Internal error")
	}

	_, hdl, err := w.GetServiceAndHandler(ctx)
	if err != nil {
		return ctx, errors.Wrap(err, "Internal error. Can't get service")
	}

	command := telegram.CommandName(data[0])

	pi, err := reqctx.GetProcessInfo(ctx)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error getting process info")
	}

	if pi != nil {
		pi.Command = string(command)
		pi.Params = params
	}

	c, ex := cmdMaps[command]
	if !ex {
		zlog.Ctx(ctx).Info().Str("Cmd", string(command)).Msg("Unknown command")
		w.postProcessRequest(ctx, PurchaseRequest, apptg.Response{}, errors.New("Unknown command"))

		return ctx, nil
	}

	ctx, aclErr := hdl.Authorization(ctx, command, params)
	if aclErr != nil {
		w.HandleAuthError(ctx, CallbackRequest, aclErr)

		return ctx, nil
	}

	w.processRequest(ctx, CallbackRequest, hdl, c, params)

	return ctx, nil
}

func (w *Worker) TextMessage(ctx context.Context, message *tgbotapi.Message) (context.Context, error) {
	zlog.Ctx(ctx).Info().Interface("text", message).Msg("Text message received")

	tgActor := telegram.Actor{
		ID:           message.From.ID,
		Username:     message.From.UserName,
		FirstName:    message.From.FirstName,
		LastName:     message.From.LastName,
		LanguageCode: message.From.LanguageCode,
	}

	ctx, err := reqctx.SetMsgContext(ctx, &tgActor, message.Chat.ID, message.MessageID, "")
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error setting request context")

		return ctx, errors.Wrap(err, "Internal error")
	}

	_, hdl, err := w.GetServiceAndHandler(ctx)
	if err != nil {
		return ctx, errors.Wrap(err, "Internal error. Can't get service")
	}

	var command telegram.CommandName

	startParam := 0

	pp := ""

	switch {
	case len(message.Entities) != 0:
		for _, entity := range message.Entities {
			if entity.Type == "bot_command" {
				command = telegram.CommandName(message.Text[entity.Offset+1 : entity.Offset+entity.Length])

				startParam = entity.Offset + entity.Length + 1

				break
			}
		}

		if command != "" {
			break
		}

		fallthrough

	case message.Text != "":
		userState, err := w.GetUserState(ctx)
		if err != nil {
			zlog.Ctx(ctx).Error().Err(err).Msg("Error getting admin state")

			return ctx, nil
		}

		if userState != "" {
			stateParams := strings.SplitN(userState, ":", 2)
			command = telegram.CommandName(stateParams[0])
			if len(stateParams) == 2 {
				pp = stateParams[1]
			}
		}
	}

	if command == "" {
		zlog.Ctx(ctx).Info().Msg("unknown message. Skip")

		return ctx, nil
	}

	pi, err := reqctx.GetProcessInfo(ctx)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error getting process info")
	}

	if pi != nil {
		pi.Command = string(command)
	}

	c, ex := cmdMaps[command]
	if !ex {
		zlog.Ctx(ctx).Info().Str("Cmd", string(command)).Msg("Unknown command")
		w.postProcessRequest(ctx, PurchaseRequest, apptg.Response{}, errors.New("Unknown command"))

		return ctx, nil
	}

	if c.NeedMsg {
		if message.Text == "" {
			zlog.Ctx(ctx).Error().Msg("Empty message")
			w.postProcessRequest(ctx, PurchaseRequest, apptg.Response{}, errors.New("Empty message"))

			return ctx, nil
		}

		if len(message.Text) > startParam {
			if pp != "" {
				pp += ":"
			}

			pp += message.Text[startParam:]
		}
	}

	if pi != nil {
		pi.Params = pp
	}

	ctx, aclErr := hdl.Authorization(ctx, command, pp)
	if aclErr != nil {
		w.HandleAuthError(ctx, TextRequest, aclErr)

		return ctx, nil
	}

	w.processRequest(ctx, TextRequest, hdl, c, pp)

	return ctx, nil
}
