package telegrambot

import (
	"context"
	"strings"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	tgbotapi "github.com/OvyFlash/telegram-bot-api"
	"github.com/pkg/errors"
	{{ .Logger.Import }}

	"{{ .ProjectPath }}/internal/app/constant"
	"{{ .ProjectPath }}/internal/app/worker/telegrambot/handler"
	"{{ .ProjectPath }}/internal/pkg/service"
	"{{ .ProjectPath }}/pkg/drivers/telegram"
	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
)

func (w *Worker) GetServiceAndHandler(ctx context.Context, rd telegram.RequestData) (*service.EmptyService, *handler.Handler, error) {
	srv, err := w.GetEmptySrv()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Internal error. Can't get service")
	}

	return srv, handler.NewHandler(srv, rd), nil
}

func (w *Worker) PreCheckout(ctx context.Context, preCheckoutQuery *tgbotapi.PreCheckoutQuery) (context.Context, error) {
	if preCheckoutQuery == nil {
		return ctx, errors.New("preCheckout is empty")
	}

	requestData := telegram.RequestData{
		Type:      telegram.PreCheckoutRequest,
		Actor: telegram.Actor{
			ID:           preCheckoutQuery.From.ID,
			FirstName:    preCheckoutQuery.From.FirstName,
			LastName:     preCheckoutQuery.From.LastName,
			Username:     preCheckoutQuery.From.UserName,
			LanguageCode: preCheckoutQuery.From.LanguageCode,
		},
		Commands:  w.GetCommandList(),
	}

	srv, hdl, err := w.GetServiceAndHandler(ctx, requestData)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Error getting service and handler" }}

		return ctx, errors.Wrap(err, "Internal error")
	}

	ctx, aclErr := hdl.Authorization(ctx, requestData, "")
	if aclErr != nil {
		w.HandleAuthError(ctx, requestData, aclErr)

		return ctx, errors.Wrap(err, "Internal error")
	}

	invoice := telegram.TelegramInvoiceData{
		Products: srv.NewInvoiceProducts(),
	}

	err = telegram.UnpackInvoiceData(ctx, &invoice, preCheckoutQuery.InvoicePayload)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "error unpacking invoice data" }}

		return ctx, errors.New("Invalid invoice")
	}

	_, desc, ok := srv.CheckInvoiceProducts(ctx, invoice, telegram.PaymentTypeStars, preCheckoutQuery.TotalAmount)
	if !ok {
		{{ .Logger.ErrorMsg "ctx" "nil" "invalid invoice products" "str::description::desc" }}

		return ctx, errors.New("Invalid invoice")
	}
	
	if preCheckoutQuery.From.ID != invoice.UserID {
		{{ .Logger.ErrorMsg "ctx" "nil" "userID mismatch" }}

		return ctx, errors.New("User ID mismatch")
	}

	err = srv.CreateTelegramPayment(ctx, invoice.IdempotencyKey, invoice.Products, preCheckoutQuery.TotalAmount, desc)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "error inserting payment" }}

		return ctx, telegram.ErrInternalError
	}

	return ctx, nil
}

func (w *Worker) Purchase(ctx context.Context, message *tgbotapi.Message) (context.Context, error) {
	requestData := telegram.RequestData{
		Type:      telegram.PurchaseRequest,
		ChatID:    message.Chat.ID,
		Actor: telegram.Actor{
			ID:           message.From.ID,
			FirstName:    message.From.FirstName,
			LastName:     message.From.LastName,
			Username:     message.From.UserName,
			LanguageCode: message.From.LanguageCode,
		},
		MessageID: message.MessageID,
		Commands:  w.GetCommandList(),
	}

	srv, hdl, err := w.GetServiceAndHandler(ctx, requestData)
	if err != nil {
		return ctx, errors.Wrap(err, "Internal error. Can't get service")
	}

	ctx, aclErr := hdl.Authorization(ctx, requestData, "")
	if aclErr != nil {
		w.HandleAuthError(ctx, requestData, aclErr)

		return ctx, errors.Wrap(err, "Internal error")
	}

	devstand, err := onlineconf.GetBool(ctx, onlineconf.MakePath(constant.ServiceName, "devstand"), false)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Unexpected error from onlineconf" }}
	}

	// settings/auto_refund_disable - позволяет отключить авторефанд на devstand
	autoRefundDisable, _ := onlineconf.GetBool(ctx, onlineconf.MakePath(constant.ServiceName, "settings", "auto_refund_disable"), false)

	invoice := telegram.TelegramInvoiceData{
		Products: srv.NewInvoiceProducts(),
	}

	err = telegram.UnpackInvoiceData(ctx, &invoice, message.SuccessfulPayment.InvoicePayload)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "error unpacking invoice data" }}

		return ctx, errors.New("Invalid invoice")
	}

	defer func() {
		if devstand && !autoRefundDisable {
			err = srv.TelegramRefundPayment(ctx, message.From.ID, message.SuccessfulPayment.TelegramPaymentChargeID)
			if err != nil {
				{{ .Logger.ErrorMsg "ctx" "err" "Error refunding payment" }}
			}
		}
	}()

	resp, err := hdl.ProcessPayment(ctx, invoice.IdempotencyKey, message.SuccessfulPayment)
	w.postProcessRequest(ctx, requestData, resp, err)
		
	return ctx, nil
}

func (w *Worker) CallbackQuery(ctx context.Context, callback *tgbotapi.CallbackQuery) (context.Context, error) {
	{{ .Logger.DebugMsg "ctx" "Text callback received" "any::text::callback" }}

	data := strings.SplitN(callback.Data[1:], ":", 2)

	params := ""
	if len(data) > 1 {
		params = data[1]
	}

	command := telegram.CommandName(data[0])

	pi, err := reqctx.GetProcessInfo(ctx)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Error getting process info" }}
	}

	if pi != nil {
		pi.Command = string(command)
		pi.Params = params
	}

	requestData := telegram.RequestData{
		Type:       telegram.CallbackRequest,
		ChatID:     callback.Message.Chat.ID,
		Actor: telegram.Actor{
			ID:           callback.From.ID,
			FirstName:    callback.From.FirstName,
			LastName:     callback.From.LastName,
			Username:     callback.From.UserName,
			LanguageCode: callback.From.LanguageCode,
		},
		CallbackID: callback.ID,
		MessageID:  callback.Message.MessageID,
		Commands:   w.GetCommandList(),
	}

	c, ex := cmdMaps[command]
	if !ex {
		{{ .Logger.InfoMsg "ctx" "Unknown command" "str::Cmd::string(command)" }}
		w.postProcessRequest(ctx, requestData, telegram.Response{}, errors.New("Unknown command"))

		return ctx, nil
	}

	requestData.Command = c

	_, hdl, err := w.GetServiceAndHandler(ctx, requestData)
	if err != nil {
		return ctx, errors.Wrap(err, "Internal error. Can't get service")
	}

	ctx, aclErr := hdl.Authorization(ctx, requestData, params)
	if aclErr != nil {
		w.HandleAuthError(ctx, requestData, aclErr)

		return ctx, nil
	}

	w.processRequest(ctx, hdl, c, params)

	return ctx, nil
}

func (w *Worker) TextMessage(ctx context.Context, message *tgbotapi.Message) (context.Context, error) {
	{{ .Logger.DebugMsg "ctx" "Text message received" "any::text::message" }}

	var command telegram.CommandName

	startParam := 0

	pp := ""

	switch {
	case len(message.Entities) != 0:
		for _, entity := range message.Entities {
			if entity.Type == "bot_command" {
				command = telegram.CommandName(message.Text[entity.Offset+1 : entity.Offset+entity.Length])

				startParam = entity.Offset + entity.Length + 1

				break
			}
		}

		if command != "" {
			break
		}

		fallthrough

	case message.Text != "":
		userState, err := w.GetUserState(ctx, message.From.ID)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "Error getting admin state" }}

			return ctx, nil
		}

		if userState != "" {
			stateParams := strings.SplitN(userState, ":", 2)
			command = telegram.CommandName(stateParams[0])
			if len(stateParams) == 2 {
				pp = stateParams[1]
			}
		}
	}

	if command == "" {
		{{ .Logger.InfoMsg "ctx" "unknown message. Skip" }}

		return ctx, nil
	}

	pi, err := reqctx.GetProcessInfo(ctx)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Error getting process info" }}
	}

	if pi != nil {
		pi.Command = string(command)
	}

	requestData := telegram.RequestData{
		Type:      telegram.TextRequest,
		ChatID:    message.Chat.ID,
		Actor: telegram.Actor{
			ID:           message.From.ID,
			FirstName:    message.From.FirstName,
			LastName:     message.From.LastName,
			Username:     message.From.UserName,
			LanguageCode: message.From.LanguageCode,
		},
		MessageID: message.MessageID,
		Commands:  w.GetCommandList(),
	}

	c, ex := cmdMaps[command]
	if !ex {
		{{ .Logger.InfoMsg "ctx" "Unknown command" "str::Cmd::string(command)" }}
		w.postProcessRequest(ctx, requestData, telegram.Response{}, errors.New("Unknown command"))

		return ctx, nil
	}

	requestData.Command = c

	if c.NeedMsg {
		if message.Text == "" {
			{{ .Logger.ErrorMsg "ctx" "nil" "Empty message" }}
			w.postProcessRequest(ctx, requestData, telegram.Response{}, errors.New("Empty message"))

			return ctx, nil
		}

		if len(message.Text) > startParam {
			if pp != "" {
				pp += ":"
			}

			pp += message.Text[startParam:]
		}
	}

	if pi != nil {
		pi.Params = pp
	}

	_, hdl, err := w.GetServiceAndHandler(ctx, requestData)
	if err != nil {
		return ctx, errors.Wrap(err, "Internal error. Can't get service")
	}

	ctx, aclErr := hdl.Authorization(ctx, requestData, pp)
	if aclErr != nil {
		w.HandleAuthError(ctx, requestData, aclErr)

		return ctx, nil
	}

	w.processRequest(ctx, hdl, c, pp)

	return ctx, nil
}

func (w *Worker) DocumentMessage(ctx context.Context, message *tgbotapi.Message) (context.Context, error) {
	{{ .Logger.DebugMsg "ctx" "Document message received" "any::document::message.Document" }}

	// Получаем состояние пользователя для определения команды
	userState, err := w.GetUserState(ctx, message.From.ID)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Error getting user state" }}

		return ctx, nil
	}

	if userState == "" {
		{{ .Logger.InfoMsg "ctx" "No user state for document. Skip" }}

		return ctx, nil
	}

	stateParams := strings.SplitN(userState, ":", 2)
	command := telegram.CommandName(stateParams[0])
	pp := ""
	if len(stateParams) == 2 {
		pp = stateParams[1]
	}

	pi, err := reqctx.GetProcessInfo(ctx)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Error getting process info" }}
	}

	if pi != nil {
		pi.Command = string(command)
	}

	// Получаем сервис для доступа к telegram driver
	srv, err := w.GetEmptySrv()
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Failed to get service" }}

		return ctx, err
	}

	// Загружаем URL файла через Bot API
	fileURL, err := srv.GetFileDirectURL(message.Document.FileID)
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "Failed to get file URL" }}

		return ctx, err
	}

	requestData := telegram.RequestData{
		Type:      telegram.TextRequest,
		ChatID:    message.Chat.ID,
		Actor: telegram.Actor{
			ID:           message.From.ID,
			FirstName:    message.From.FirstName,
			LastName:     message.From.LastName,
			Username:     message.From.UserName,
			LanguageCode: message.From.LanguageCode,
		},
		MessageID: message.MessageID,
		Commands:  w.GetCommandList(),
	}

	c, ex := cmdMaps[command]
	if !ex {
		{{ .Logger.InfoMsg "ctx" "Unknown command" "str::Cmd::string(command)" }}
		w.postProcessRequest(ctx, requestData, telegram.Response{}, errors.New("Unknown command"))

		return ctx, nil
	}

	requestData.Command = c

	_, hdl, err := w.GetServiceAndHandler(ctx, requestData)
	if err != nil {
		return ctx, errors.Wrap(err, "Internal error. Can't get service")
	}

	// Упаковываем файл в параметры: file:URL:filename:остальные_параметры
	ppWithFile := telegram.PackFileParam(fileURL, message.Document.FileName, pp)

	ctx, aclErr := hdl.Authorization(ctx, requestData, ppWithFile)
	if aclErr != nil {
		w.HandleAuthError(ctx, requestData, aclErr)

		return ctx, nil
	}

	// Передаем параметры с файлом
	// Проверка наличия файла происходит в Unpack() метода соответствующих параметров
	w.processRequest(ctx, hdl, c, ppWithFile)

	return ctx, nil
}
