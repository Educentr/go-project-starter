package telegram

import (
	"context"
	"errors"

	"github.com/gofrs/uuid/v5"
)

type UnimplementedPayment struct {
}

func (UnimplementedPayment) CheckInvoiceProducts(ctx context.Context, invoice TelegramInvoiceData, paymentType PaymentType, totalAmount int) (string, bool) {
	return "unimplemented", false
}

// This function should create a payment record in the database.
// For now, we will just return nil to indicate success.
func (UnimplementedPayment) CreateTelegramPayment(ctx context.Context, idempotencyKey uuid.UUID, products InvoiceProduct, amount int, description string) error {
	return errors.New("unimplemented")
}

// This function should process the payment.
// For now, we will just return nil to indicate success.
func (UnimplementedPayment) ProcessPayment(ctx context.Context, idempotency uuid.UUID, paymentChargeID string) error {
	return errors.New("unimplemented")
}

type BaseAuth struct {
}

func (s *BaseAuth) HasAdminRole(ctx context.Context, tgID int64, role string) (bool, error) {
	if tgID == 0 {
		return false, errors.New("userID is nil")
	}

	acl, exists, err := onlineconf.GetStringIfExists(ctx, onlineconf.MakePath("{{ .ProjectName }}", "bot", "admins", strconv.FormatInt(tgID, 10)))
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Failed to get admin ACL from onlineconf")
		return false, err
	}

	if !exists {
		return false, nil
	}

	rxNew, err := regexp.Compile(role)
	if err != nil {
		zlog.Ctx(ctx).Error().Err(err).Msg("Error compiling regex for full access check")

		return false, err
	}

	return rxNew.MatchString(acl), nil
}

func (s *BaseAuth) IsUserAdmin(ctx context.Context, tgID int64) (bool, error) {
	return s.HasAdminRole(ctx, tgID, `full`)
}

type ChatType string

const (
	PrivateChat ChatType = "private"
	GroupChat   ChatType = "group"
)

var (
	ErrUserNotFound = errors.New("admin not found")
	ErrAccessDenied  = errors.New("access denied")
	ErrInternalError = errors.New("internal error")
)

func (s *BaseAuth) TgBotAuthorization(ctx context.Context, cmd Cmd, chatType ChatType, tgID int64) error {
	if cmd.Group == (chatType == PrivateChat) {
		return ErrAccessDenied
	}

	strTgID := strconv.FormatInt(tgID, 10)

	if cmd.NeedAdminAccess {
		acl, ex, err := onlineconf.GetStringIfExists(ctx, onlineconf.MakePath(constant.ServiceName, "bot", "admins", strTgID))
		if err != nil {
			zlog.Ctx(ctx).Error().Err(err).Msg("Get onlineconf admin")

			return ErrInternalError
		}

		if ex {
			// Any admin has access
			if len(cmd.AdminRole) == 0 {
				return nil
			}

			rxStr := `(^|,)(role:(`

			quotedRoles := []string{}
			for _, r := range cmd.AdminRole {
				quotedRoles = append(quotedRoles, regexp.QuoteMeta(string(r)))
			}

			rxStr += strings.Join(quotedRoles, "|") + `|root)|` + regexp.QuoteMeta(cmd.Name.String()) + `)(,|$)`

			rxNew, err := regexp.Compile(rxStr)
			if err != nil {
				zlog.Ctx(ctx).Error().Err(err).Msg("Error compiling regex")

				return ErrInternalError
			}

			// Check specific role or command access
			if rxNew.MatchString(acl) {
				return nil
			}
		}

		return ErrAccessDenied
	}

	paths := []string{
		onlineconf.MakePath(constant.ServiceName, "bot", "users"),
		onlineconf.MakePath(constant.ServiceName, "bot", "users", strTgID),
	}

	for _, param := range paths {
		acl, ex, err := onlineconf.GetStringIfExists(ctx, param)
		if err != nil {
			zlog.Ctx(ctx).Error().Err(err).Msg("Get onlineconf admin")

			return ErrInternalError
		}

		if !ex {
			continue
		}

		rxNew, err := regexp.Compile(`(^|,)(full|` + regexp.QuoteMeta(cmd.Name.String()) + `)(,|$)`)
		if err != nil {
			zlog.Ctx(ctx).Error().Err(err).Msg("Error compiling regex")

			return ErrInternalError
		}

		if rxNew.MatchString(acl) {
			return nil
		}
	}

	return ErrAccessDenied
}