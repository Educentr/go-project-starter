package telegram

import (
	"context"
	"errors"

	{{ .Logger.Import }}

	tgbotapi "github.com/OvyFlash/telegram-bot-api"
)

func ConvertButtonCMDToTgButton(ctx context.Context, btn [][]ButtonCmd) ([][]tgbotapi.InlineKeyboardButton, error) {
	tgBtn := make([][]tgbotapi.InlineKeyboardButton, len(btn))

	for i := range btn {
		tgBtn[i] = make([]tgbotapi.InlineKeyboardButton, 0, len(btn[i]))

		for j := range btn[i] {
			if btn[i][j].URL != "" {
				if len(btn[i][j].URL) > 256 {
					zlog.Ctx(ctx).Error().Int("Len", len(btn[i][j].URL)).Str("Text", btn[i][j].Text).Str("URL", btn[i][j].URL).Msg("Button URL too long")
					
					continue
				}

				tgBtn[i] = append(tgBtn[i], tgbotapi.NewInlineKeyboardButtonURL(btn[i][j].Text, btn[i][j].URL))

				continue
			}

			if btn[i][j].Name == EmptyCommandName {
				zlog.Ctx(ctx).Error().Msg("Empty button command name")

				continue
			}

			if btn[i][j].Text == "" {
				zlog.Ctx(ctx).Error().Msg("Empty button command text")

				continue
			}

			data := "/" + string(btn[i][j].Name) + ":" + btn[i][j].Params
			if len(data) > 64 {
				zlog.Ctx(ctx).Error().Int("Len", len(data)).Str("Text", btn[i][j].Text).Str("Data", data).Msg("Button text too long")

				continue
			}

			tgBtn[i] = append(tgBtn[i], tgbotapi.NewInlineKeyboardButtonData(btn[i][j].Text, data))
		}
	}

	return tgBtn, nil
}

func (tg *Telegram) SendAnswerCallback(_ context.Context, callbackID string, text string) (bool, error) {
	tgMes, err := tg.bot.Request(tgbotapi.CallbackConfig{
		CallbackQueryID: callbackID,
		Text:            text,
	})

	return tgMes.Ok, err
}

func (tg *Telegram) DeleteMessage(_ context.Context, chatID int64, msgID int) error {
	_, err := tg.bot.Request(tgbotapi.NewDeleteMessage(chatID, msgID))

	return err
}

func (tg *Telegram) SendMessageWithButton(ctx context.Context, chatID int64, msg Message) (int, error) {
	btn, err := ConvertButtonCMDToTgButton(ctx, msg.Btn)
	if err != nil {
		return 0, err
	}

	switch {
	case len(msg.Photos) > 0:
		if len(msg.Photos) > 1 {
			return 0, errors.New("send message with more than one image is not supported")
		}

		msgTg := tgbotapi.NewPhoto(chatID, tgbotapi.FilePath(msg.Photos[0]));
		msgTg.Caption = msg.Text

		if msg.TextFormat != "" {
			msgTg.ParseMode = msg.TextFormat
		}

		if len(msg.Btn) != 0 {
			msgTg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(btn...)
		}

		return tg.send(msgTg)
	default:
		msgTg := tgbotapi.NewMessage(chatID, msg.Text)		

		if len(msg.Btn) != 0 {
			msgTg.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(btn...)
		}

		if msg.TextFormat != "" {
			msgTg.ParseMode = msg.TextFormat
		}
		
		return tg.send(msgTg)
	}
}

func (tg *Telegram) EditMessageWithButton(ctx context.Context, chatID int64, msgID int, msg Message) error {
	btn, err := ConvertButtonCMDToTgButton(ctx, msg.Btn)
	if err != nil {
		return err
	}

	switch {
	case len(msg.Photos) > 0:
		if len(msg.Photos) > 1 {
			return errors.New("send message with more than one image is not supported")
		}

		mediaPhoto := tgbotapi.NewInputMediaPhoto(tgbotapi.FilePath(msg.Photos[0]))
		mediaPhoto.Caption = msg.Text

		if msg.TextFormat != "" {
			mediaPhoto.ParseMode = msg.TextFormat
		}

		msgTg := tgbotapi.NewEditMessagePhoto(chatID, msgID, mediaPhoto)

		if len(msg.Btn) != 0 {
			markup := tgbotapi.NewInlineKeyboardMarkup(btn...)
			msgTg.ReplyMarkup = &markup
		}

		_, err = tg.bot.Request(msgTg)

		return err
	default:
		msgTg := tgbotapi.NewEditMessageTextAndMarkup(chatID, msgID, msg.Text, tgbotapi.NewInlineKeyboardMarkup(btn...))

		if msg.TextFormat != "" {
			msgTg.ParseMode = msg.TextFormat
		}

		_, err = tg.bot.Request(msgTg)

		return err
	}
}

func (tg *Telegram) send(msg tgbotapi.Chattable) (int, error) {
	if tg.bot == nil {
		return 0, errors.New("telegram bot is not initialized")
	}
	
	tgMsg, err := tg.bot.Send(msg)
	if err != nil {
		return 0, err
	}

	return tgMsg.MessageID, nil
}
