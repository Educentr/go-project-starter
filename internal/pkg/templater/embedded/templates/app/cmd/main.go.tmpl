package main

import (
	"context"
	"log"
	"os"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/joho/godotenv"
	{{ .Logger.Import }}
	{{ if .Application.UseActiveRecord }}
	"github.com/Educentr/go-activerecord/v3/pkg/activerecord"
	arlogger "github.com/Educentr/go-activerecord/v3/pkg/logger"
	"github.com/Educentr/go-activerecord/v3/pkg/logger/arzlog"
	{{- end }}

	"{{ .ProjectPath }}/internal/app/constant"
	{{ range $_, $imp := .Application.TransportImports }}
	{{ $imp }}
	{{- end }}
	{{- /* Client imports for ogen_client (static only) and buf_client */ -}}
	{{ range $_, $tr := .Application.GetRestTransport }}
	{{ if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) }}
	{{ range $_, $imp := $tr.Import }}
	{{ $imp }}
	{{- end }}
	{{- end }}
	{{- end }}
	{{ range $_, $tr := .Application.GetGrpcTransport }}
	{{ if eq $tr.GeneratorType "buf_client" }}
	{{ range $_, $imp := $tr.Import }}
	{{ $imp }}
	{{- end }}
	{{- end }}
	{{- end }}
	{{ range $_, $drv := .Application.Drivers }}
	{{ $drv.Package }} "{{ $drv.Import }}"
	{{ end }}
	{{ range $_, $imp := .Application.KafkaImports $.ProjectPath }}
	"{{ $imp }}"
	{{- end }}
	{{ range $_, $imp := .Application.WorkerImports }}
	{{ $imp }}
	{{- end }}
	"{{ .ProjectPath }}/internal/pkg/service"
	"github.com/Educentr/go-project-starter-runtime/pkg/app"
	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
	runtimelogger "github.com/Educentr/go-project-starter-runtime/pkg/logger"
	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
	"{{ .ProjectPath }}/pkg/app/logger"
	{{- if .Application.GetRestTransport }}
	"{{ .ProjectPath }}/pkg/app/rest"
	{{- end }}
)

const (
	ExitCodeOK = iota
	ExitCodeErrorConfig
	ExitCodeErrorApp
	ExitCodeErrorDriver
	ExitCodeErrorTransport
	ExitCodeErrorService
	ExitCodeInit
	ExitCodeErrorRun
)

const (
	envFileName            = ".env"
	defaultOnlineconfDir   = "etc/onlineconf"
	onlineconfDirEnvVar    = "ONLINECONF_DIR"
)

// ldflags
var (
	Version     string
	BuildTime   string
	BuildOS     string
	BuildCommit string
)

type UserSetFunc struct {
	app.EmptyUserSetFunc
}

func main() {
	// initialization parent background context
	mainCtx := context.Background()

	_, err := os.Lstat(envFileName)
	if !os.IsNotExist(err) {
		err := godotenv.Load(envFileName)
		if err != nil {
			log.Fatal("Error loading .env file")
		}
	}

	// Initialize onlineconf
	mainCtx, err = onlineconf.Initialize(mainCtx, onlineconf.WithConfigDir(getOnlineconfDir()))
	if err != nil {
		log.Printf("failed to initialize onlineconf: %v", err)
		os.Exit(ExitCodeErrorConfig)
	}

	// Инициализация логгера
	mainCtx = {{ .Logger.InitLogger "mainCtx" "constant.ServiceName" }}

	// Set logger updater for reqctx
	{{ .Logger.SetLoggerUpdater }}

	err = onlineconf.StartWatcher(mainCtx)
    if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't start watcher" }}
		os.Exit(ExitCodeErrorConfig)
    }

	application, err := app.New(mainCtx, constant.ServiceName, "{{ .Application.Name }}", getAppInfo())
	if err != nil {
		log.Printf("can't create new application: %s", err)
		os.Exit(ExitCodeErrorApp)
	}

	{{ .Logger.InfoMsg "mainCtx" "application created" }}
{{- if .Application.HasSysTransport }}

	// Initialize metrics (only when sys transport is available for /metrics endpoint)
	err = application.InitMetrics(mainCtx)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't initialize metrics" }}
		os.Exit(ExitCodeErrorApp)
	}
{{- end }}

	// initializing graceful stop for application
	mainCtx = application.InitGracefulStop(mainCtx)

	userFunc := UserSetFunc{}

	err = userFunc.SetFunc(mainCtx, application)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't set user func" }}
		os.Exit(ExitCodeErrorApp)
	}

	application.SetDriver(
		{{ range $_, $drv := .Application.Drivers }}
		{{ $drv.Package }}.Create( {{ range $_, $param := $drv.CreateParams }}{{ $drv.Package }}.{{ $param }}, {{ end }} ),
		{{ end }}
		{{ range $_, $kafka := .Application.GetKafkaProducers }}
		{{ $kafka.GetPackage }}.Create(),
		{{ end }}
	)

	// Register clients (ogen_client static only, buf_client) for initialization in service
	// Dynamic clients are created at runtime, not at startup
	application.SetClient(
		{{ range $_, $tr := .Application.GetRestTransport }}
		{{ if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) }}
		{{ $tr.Name }}.NewClient(),
		{{- end }}
		{{- end }}
		{{ range $_, $tr := .Application.GetGrpcTransport }}
		{{ if eq $tr.GeneratorType "buf_client" }}
		{{ $tr.Name }}Client.NewClient(),
		{{- end }}
		{{- end }}
	)

	err = application.SetTransport(
		{{ range $_, $tr := .Application.Transports }}
		{{ if and (ne $tr.GeneratorType "ogen_client") (ne $tr.GeneratorType "buf_client") }}
		{{ $tr.Init }},
		{{- end }}
		{{- end }}
	)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't set transport" }}
		os.Exit(ExitCodeErrorTransport)
	}

	err = application.SetWorker(
		{{ range $_, $wr := .Application.Workers }}
		{{ $wr.Name }}Worker.Create(),
		{{ end }}
	)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't set worker" }}
		os.Exit(ExitCodeErrorTransport)
	}

	srv, err := service.NewService(mainCtx)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't create new service" }}
		os.Exit(ExitCodeErrorService)
	}

	err = application.SetService(srv)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't set service" }}
		os.Exit(ExitCodeErrorService)
	}

	// Initializing app
	err = application.Init(mainCtx)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't initialize application" }}
		os.Exit(ExitCodeInit)
	}
	{{ if .Application.UseActiveRecord }}
	// Initialize ActiveRecord
	activerecord.InitActiveRecord(
		activerecord.WithLogger(arzlog.NewARLogger(arlogger.InfoLoggerLevel)),
		activerecord.WithConfig(func(ctx context.Context) activerecord.ConfigInterface { return onlineconf.FromContext(ctx) }),
		activerecord.WithMetrics(activerecord.NewARMetrics(application.GetMetrics(), nil)),
	)
	{{- end }}

	err = application.Run(mainCtx)
	if err != nil {
		{{ .Logger.ErrorMsg "mainCtx" "err" "can't start application" }}
		os.Exit(ExitCodeErrorRun)
	}
	 
	onlineconf.StopWatcher(mainCtx)

	{{ .Logger.WarnMsg "mainCtx" "service has been successfully shutdown" }}
}

func getAppInfo() *ds.AppInfo {
	return ds.NewAppInfo(constant.ServiceName).
		WithVersion(Version).
		WithBuildTime(BuildTime).
		WithBuildOS(BuildOS).
		WithBuildCommit(BuildCommit)
}

// getOnlineconfDir returns the onlineconf config directory path.
// It checks ONLINECONF_DIR environment variable first, falls back to default.
func getOnlineconfDir() string {
	if dir := os.Getenv(onlineconfDirEnvVar); dir != "" {
		return dir
	}

	return defaultOnlineconfDir
}
