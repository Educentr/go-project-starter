// Code generated by go-project-starter. DO NOT EDIT.
package tests

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

// HTTPMockAddress is the address for HTTP mock server (GOAT default)
const HTTPMockAddress = "http://127.0.0.1:9898"

// HTTPClient provides methods for making HTTP requests to the API
type HTTPClient struct {
	BaseURL    string
	HTTPClient *http.Client
	AuthToken  string
}

// NewHTTPClient creates a new HTTP client for testing
func NewHTTPClient(baseURL string) *HTTPClient {
	return &HTTPClient{
		BaseURL: baseURL,
		HTTPClient: &http.Client{
			Timeout: 10 * time.Second,
		},
	}
}

// WithAuth sets the authentication token for requests
func (c *HTTPClient) WithAuth(token string) *HTTPClient {
	c.AuthToken = token
	return c
}

// Post makes a POST request to the API
func (c *HTTPClient) Post(t *testing.T, path string, body interface{}) (*http.Response, []byte) {
	t.Helper()

	var bodyReader io.Reader
	if body != nil {
		jsonBody, err := json.Marshal(body)
		require.NoError(t, err)
		bodyReader = bytes.NewBuffer(jsonBody)
	}

	req, err := http.NewRequest(http.MethodPost, c.BaseURL+path, bodyReader)
	require.NoError(t, err)

	req.Header.Set("Content-Type", "application/json")
	if c.AuthToken != "" {
		req.Header.Set("X-Auth", c.AuthToken)
	}

	resp, err := c.HTTPClient.Do(req)
	require.NoError(t, err)

	respBody, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	resp.Body.Close()

	return resp, respBody
}

// Get makes a GET request to the API
func (c *HTTPClient) Get(t *testing.T, path string) (*http.Response, []byte) {
	t.Helper()

	req, err := http.NewRequest(http.MethodGet, c.BaseURL+path, nil)
	require.NoError(t, err)

	if c.AuthToken != "" {
		req.Header.Set("X-Auth", c.AuthToken)
	}

	resp, err := c.HTTPClient.Do(req)
	require.NoError(t, err)

	respBody, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	resp.Body.Close()

	return resp, respBody
}

// GetWithHeaders makes a GET request to the API with custom headers
func (c *HTTPClient) GetWithHeaders(t *testing.T, path string, headers map[string]string) (*http.Response, []byte) {
	t.Helper()

	req, err := http.NewRequest(http.MethodGet, c.BaseURL+path, nil)
	require.NoError(t, err)

	if c.AuthToken != "" {
		req.Header.Set("X-Auth", c.AuthToken)
	}

	// Set custom headers
	for key, value := range headers {
		req.Header.Set(key, value)
	}

	resp, err := c.HTTPClient.Do(req)
	require.NoError(t, err)

	respBody, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	resp.Body.Close()

	return resp, respBody
}

// TestRetryConfig contains retry configuration for tests
var TestRetryConfig = struct {
	MaxAttempts       int
	InitialInterval   time.Duration
	MaxInterval       time.Duration
	BackoffMultiplier float64
}{
	MaxAttempts:       5,
	InitialInterval:   500 * time.Millisecond,
	MaxInterval:       5 * time.Second,
	BackoffMultiplier: 2.0,
}

// WaitForAPI waits for the API to be ready with exponential backoff retry
func WaitForAPI(t *testing.T, baseURL string, maxWait time.Duration) error {
	t.Helper()

	client := &http.Client{
		Timeout: 2 * time.Second,
	}

	// Use exponential backoff for retries
	interval := TestRetryConfig.InitialInterval
	attempt := 0
	deadline := time.Now().Add(maxWait)

	t.Logf("Waiting for API at %s (max wait: %v)", baseURL, maxWait)

	for time.Now().Before(deadline) {
		attempt++

		// Try to connect to a simple endpoint
		resp, err := client.Get(baseURL + "/ready")
		if err == nil && resp.StatusCode == http.StatusOK {
			resp.Body.Close()
			t.Logf("API is ready after %d attempts", attempt)
			return nil
		}
		if resp != nil {
			resp.Body.Close()
			t.Logf("API returned status %d (attempt %d), retrying...", resp.StatusCode, attempt)
		} else {
			t.Logf("API connection failed (attempt %d): %v, retrying...", attempt, err)
		}

		// Check if we've exhausted max attempts
		if attempt >= TestRetryConfig.MaxAttempts && time.Now().Add(interval).After(deadline) {
			break
		}

		// Sleep with current interval
		sleepTime := interval
		if time.Now().Add(sleepTime).After(deadline) {
			// Adjust sleep time to not exceed deadline
			sleepTime = time.Until(deadline)
		}

		if sleepTime > 0 {
			time.Sleep(sleepTime)
		}

		// Exponential backoff: increase interval for next iteration
		interval = time.Duration(float64(interval) * TestRetryConfig.BackoffMultiplier)
		if interval > TestRetryConfig.MaxInterval {
			interval = TestRetryConfig.MaxInterval
		}
	}

	return fmt.Errorf("API did not become ready within %v after %d attempts", maxWait, attempt)
}

// ParseJSONResponse parses a JSON response into the provided interface
func ParseJSONResponse(t *testing.T, body []byte, target interface{}) {
	t.Helper()

	err := json.Unmarshal(body, target)
	require.NoError(t, err, "Failed to parse JSON response: %s", string(body))
}

// PrettyPrintJSON pretty prints JSON for debugging
func PrettyPrintJSON(t *testing.T, data interface{}) {
	t.Helper()

	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		t.Logf("Failed to marshal JSON: %v", err)
		return
	}

	t.Logf("JSON:\n%s", string(jsonData))
}
