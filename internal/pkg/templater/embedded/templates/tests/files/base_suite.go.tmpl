// Code generated by go-project-starter. DO NOT EDIT.
package tests

import (
	"context"
	"testing"
	"time"

	gtt "github.com/Educentr/goat"
	"github.com/stretchr/testify/suite"
)

// BaseTestSuite provides common functionality for all test suites
// It handles database initialization, API startup, and cleanup
type BaseTestSuite struct {
	suite.Suite
	ctx    context.Context
	env    *gtt.Env
	flow   *gtt.Flow
{{ range $_, $tr := .Application.GetRestTransport }}{{ if and (ne $tr.Name "sys") (ne $tr.GeneratorType "ogen_client") }}
	{{ $tr.Name }}Client *HTTPClient
{{ end }}{{ end }}
{{ if .Application.HasOgenClients }}
	mocks  *MockServers
{{ end }}
}

// SetupSuite initializes the test environment - runs once before all tests in the suite
func (s *BaseTestSuite) SetupSuite() {
	if testing.Short() {
		s.T().Skip("Skipping integration test in short mode")
	}

	s.ctx = SetupTestContext()
	s.env = GetEnv()

{{ if .Application.UseActiveRecord }}
	// Initialize database
	err := InitTestDatabase(s.ctx, s.env)
	s.Require().NoError(err, "Failed to initialize database")

	// Initialize ActiveRecord
	err = InitActiveRecordForTest(s.ctx, s.env)
	s.Require().NoError(err, "Failed to initialize ActiveRecord")
{{ end }}

{{ if .Application.HasOgenClients }}
	// Initialize mocks holder
	s.mocks = &MockServers{}

	// Create flow with HTTP mocks
	s.flow = gtt.NewFlow(
		s.T(),
		s.env,
		NewTestApp(s.env),
		HTTPMocksSetup(s.mocks),
		nil, // No gRPC mocks needed
	)
{{ else }}
	// Create flow
	s.flow = gtt.NewFlow(
		s.T(),
		s.env,
		NewTestApp(s.env),
		nil, // HTTP mocks - extend as needed
		nil, // gRPC mocks
	)
{{ end }}

	s.flow.Start(s.T(),
		func(env *gtt.Env) error {
			s.T().Log("Starting {{ .Application.Name }} service...")
			return nil
		},
		func(env *gtt.Env) error {
			s.T().Log("Service started, waiting for readiness...")
			return WaitForAPI(s.T(), GetAPIURL(SysPort()), 30*time.Second)
		},
	)

{{ range $_, $tr := .Application.GetRestTransport }}{{ if and (ne $tr.Name "sys") (ne $tr.GeneratorType "ogen_client") }}
	s.{{ $tr.Name }}Client = NewHTTPClient(GetAPIURL({{ $tr.Name | Capitalize }}Port()))
{{ end }}{{ end }}
}

// TearDownTest cleans up after each individual test
// This ensures test isolation by cleaning up all test data between tests
func (s *BaseTestSuite) TearDownTest() {
{{ if .Application.UseActiveRecord }}
	if err := CleanupTestData(s.ctx, s.env); err != nil {
		s.T().Logf("Warning: Failed to cleanup test data: %v", err)
	}
{{ end }}
}

// TearDownSuite cleans up after all tests in the suite
func (s *BaseTestSuite) TearDownSuite() {
	if s.flow != nil {
		s.flow.Stop(s.T(),
{{ if .Application.UseActiveRecord }}
			func(env *gtt.Env) error {
				s.T().Log("Cleaning up database tables (preserving schema)...")
				// Use CleanupTestData instead of CleanupTestDatabase to preserve
				// PostgreSQL enum type OIDs. Dropping and recreating schema causes
				// "cache lookup failed for type" errors in ActiveRecord connection pool.
				return CleanupTestData(s.ctx, s.env)
			},
{{ else }}
			nil,
{{ end }}
			nil,
		)
	}
}

// GetContext returns the test context
func (s *BaseTestSuite) GetContext() context.Context {
	return s.ctx
}

// GetEnv returns the test environment
func (s *BaseTestSuite) GetEnv() *gtt.Env {
	return s.env
}

{{ if .Application.HasOgenClients }}
// Mocks returns mock servers for test assertions
func (s *BaseTestSuite) Mocks() *MockServers {
	return s.mocks
}
{{ end }}
