// Code generated by go-project-starter. DO NOT EDIT.
package tests

import (
	"context"
	"fmt"
	"os"
	"sync"

{{ if .Application.UseActiveRecord }}
	"github.com/Educentr/go-activerecord/v3/pkg/activerecord"
	"github.com/Educentr/goat-services/psql"
	"github.com/Educentr/goat/services"
{{ end }}
	gtt "github.com/Educentr/goat"
	zlog "github.com/rs/zerolog"

	"github.com/Educentr/goat/testutil"
)

var (
	env             *gtt.Env
	appConfig       testutil.TestAppConfig
	testEnvInitOnce sync.Once
{{ if .Application.UseActiveRecord }}
	activeRecordInitOnce sync.Once
{{ end }}
)

// ensureTestEnvInitialized ensures the test environment is initialized.
// Uses sync.Once to guarantee initialization happens exactly once,
// after all init() functions have completed.
func ensureTestEnvInitialized() {
	testEnvInitOnce.Do(func() {
		// Initialize test environment using TestEnvInitializer interface
		// This calls the implementation from psg_init_gen.go or user's init.go
		appConfig, env = testEnvInit.InitTestEnv()

		if appConfig == nil {
			panic("TestEnvInitializer.InitTestEnv() returned nil appConfig. Implement InitTestEnv in init.go")
		}
		if env == nil {
			panic("TestEnvInitializer.InitTestEnv() returned nil env. Implement InitTestEnv in init.go")
		}
	})
}

// NewTestApp delegates Executor creation to appConfig
func NewTestApp(e *gtt.Env) *gtt.Executor {
	ensureTestEnvInitialized()
	return appConfig.NewExecutor(e, HTTPMockAddress)
}

// GetEnv returns the initialized test environment
func GetEnv() *gtt.Env {
	ensureTestEnvInitialized()
	return env
}

// GetAppConfig returns the initialized app config
func GetAppConfig() testutil.TestAppConfig {
	ensureTestEnvInitialized()
	return appConfig
}

{{ if .Application.UseActiveRecord }}
// InitTestDatabase initializes the database through appConfig
func InitTestDatabase(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
	sql, err := pg.SQL()
	if err != nil {
		return fmt.Errorf("failed to get SQL connection: %w", err)
	}

	// Apply migrations through interface
	if err := appConfig.ApplyMigrations(ctx, sql); err != nil {
		return fmt.Errorf("failed to apply migrations: %w", err)
	}

	return nil
}

// InitActiveRecordForTest initializes ActiveRecord through appConfig
func InitActiveRecordForTest(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	activeRecordInitOnce.Do(func() {
		pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
		configMap := appConfig.ConfigMap(pg.DBHost, pg.DBPort, pg.DBUser, pg.DBPass, pg.DBName)

		activerecord.InitActiveRecord(
			activerecord.WithConfig(func(ctx context.Context) activerecord.ConfigInterface {
				return activerecord.NewDefaultConfigFromMap(configMap)
			}),
		)
	})

	return nil
}

// CleanupTestDatabase cleans up the database after tests
func CleanupTestDatabase(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
	sql, err := pg.SQL()
	if err != nil {
		return fmt.Errorf("failed to get SQL connection: %w", err)
	}

	// Drop all tables and recreate schema
	_, err = sql.Exec("DROP SCHEMA public CASCADE; CREATE SCHEMA public;")
	if err != nil {
		return fmt.Errorf("failed to cleanup database: %w", err)
	}

	return nil
}

// CleanupTestData cleans up test data through appConfig
func CleanupTestData(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
	sql, err := pg.SQL()
	if err != nil {
		return fmt.Errorf("failed to get SQL connection: %w", err)
	}

	// Cleanup tables through interface
	if err := appConfig.CleanupTables(ctx, sql); err != nil {
		return fmt.Errorf("failed to cleanup tables: %w", err)
	}

	return nil
}
{{ end }}

// SetupTestContext creates a context with logger for testing
func SetupTestContext() context.Context {
	ctx := context.Background()

	// For tests, we use a simple zerolog logger without onlineconf dependency
	testLogger := zlog.New(os.Stdout).With().
		Timestamp().
		Str("service", "test").
		Logger()

	ctx = testLogger.WithContext(ctx)
	return ctx
}

// GetAPIURL returns the base URL for the API service
func GetAPIURL(port string) string {
	return fmt.Sprintf("http://localhost:%s", port)
}

{{ range $_, $tr := .Application.GetRestTransport }}{{ if ne $tr.GeneratorType "ogen_client" }}
// {{ $tr.Name | Capitalize }}Port returns the {{ $tr.Name }} transport port
func {{ $tr.Name | Capitalize }}Port() string {
	ensureTestEnvInitialized()
	return appConfig.TransportPort("{{ $tr.Name }}")
}
{{ end }}{{ end }}
