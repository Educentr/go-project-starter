// Code generated by go-project-starter. DO NOT EDIT.
package tests

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sync"

{{ if .Application.UseActiveRecord }}
	"github.com/Educentr/go-activerecord/v3/pkg/activerecord"
	"github.com/Educentr/goat-services/psql"
{{ end }}
	gtt "github.com/Educentr/goat"
	"github.com/Educentr/goat/services"
	zlog "github.com/rs/zerolog"

	tests_pkg "{{ .ProjectPath }}/pkg/tests"
)

var (
	env                  *gtt.Env
	appConfig            tests_pkg.TestAppConfig
	testEnvInitOnce      sync.Once
{{ if .Application.UseActiveRecord }}
	activeRecordInitOnce sync.Once
{{ end }}
)

// ensureTestEnvInitialized ensures the test environment is initialized.
// Uses sync.Once to guarantee initialization happens exactly once,
// after all init() functions have completed.
func ensureTestEnvInitialized() {
	testEnvInitOnce.Do(func() {
		// Initialize test environment using TestEnvInitializer interface
		// This calls the implementation from psg_init_gen.go or user's init.go
		appConfig, env = testEnvInit.InitTestEnv()

		if appConfig == nil {
			panic("TestEnvInitializer.InitTestEnv() returned nil appConfig. Implement InitTestEnv in init.go")
		}
		if env == nil {
			panic("TestEnvInitializer.InitTestEnv() returned nil env. Implement InitTestEnv in init.go")
		}
	})
}

// NewTestApp delegates Executor creation to appConfig
func NewTestApp(e *gtt.Env) *gtt.Executor {
	ensureTestEnvInitialized()
	return appConfig.NewExecutor(e, HTTPMockAddress)
}

// GetEnv returns the initialized test environment
func GetEnv() *gtt.Env {
	ensureTestEnvInitialized()
	return env
}

// GetAppConfig returns the initialized app config
func GetAppConfig() tests_pkg.TestAppConfig {
	ensureTestEnvInitialized()
	return appConfig
}

{{ if .Application.UseActiveRecord }}
// InitTestDatabase initializes the database through appConfig
func InitTestDatabase(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
	sql, err := pg.SQL()
	if err != nil {
		return fmt.Errorf("failed to get SQL connection: %w", err)
	}

	// Check initialization through interface
	initialized, err := appConfig.IsInitialized(ctx, sql)
	if err != nil {
		return fmt.Errorf("failed to check if database is initialized: %w", err)
	}

	if initialized {
		zlog.Ctx(ctx).Info().Msg("Database already initialized, skipping migrations")
		return nil
	}

	// Migrations through interface
	migrationsPath := appConfig.MigrationsPath()

	for _, migration := range appConfig.MigrationFiles() {
		migrationPath := filepath.Join(migrationsPath, migration)
		content, err := os.ReadFile(migrationPath)
		if err != nil {
			// Skip missing files (some might be empty)
			if os.IsNotExist(err) {
				zlog.Ctx(ctx).Warn().Str("migration", migration).Msg("Migration file not found, skipping")
				continue
			}
			return fmt.Errorf("failed to read migration %s: %w", migration, err)
		}

		if len(content) == 0 {
			continue
		}

		zlog.Ctx(ctx).Info().Str("migration", migration).Msg("Executing migration")

		_, err = sql.Exec(string(content))
		if err != nil {
			return fmt.Errorf("failed to execute migration %s: %w", migration, err)
		}
	}

	return nil
}

// InitActiveRecordForTest initializes ActiveRecord through appConfig
func InitActiveRecordForTest(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	activeRecordInitOnce.Do(func() {
		pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
		configMap := appConfig.ConfigMap(pg.DBHost, pg.DBPort, pg.DBUser, pg.DBPass, pg.DBName)

		activerecord.InitActiveRecord(
			activerecord.WithConfig(func(ctx context.Context) activerecord.ConfigInterface {
				return activerecord.NewDefaultConfigFromMap(configMap)
			}),
		)
	})

	return nil
}

// CleanupTestDatabase cleans up the database after tests
func CleanupTestDatabase(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
	sql, err := pg.SQL()
	if err != nil {
		return fmt.Errorf("failed to get SQL connection: %w", err)
	}

	// Drop all tables and recreate schema
	_, err = sql.Exec("DROP SCHEMA public CASCADE; CREATE SCHEMA public;")
	if err != nil {
		return fmt.Errorf("failed to cleanup database: %w", err)
	}

	return nil
}

// CleanupTestData cleans up test data through appConfig
func CleanupTestData(ctx context.Context, e *gtt.Env) error {
	ensureTestEnvInitialized()
	pg := services.MustGetTyped[*psql.Env](e.Manager(), "postgres")
	sql, err := pg.SQL()
	if err != nil {
		return fmt.Errorf("failed to get SQL connection: %w", err)
	}

	for _, table := range appConfig.TablesToTruncate() {
		_, err = sql.Exec(fmt.Sprintf("TRUNCATE TABLE %s RESTART IDENTITY CASCADE", table))
		if err != nil {
			return fmt.Errorf("failed to truncate table %s: %w", table, err)
		}
	}

	return nil
}
{{ end }}

// SetupTestContext creates a context with logger for testing
func SetupTestContext() context.Context {
	ctx := context.Background()

	// For tests, we use a simple zerolog logger without onlineconf dependency
	testLogger := zlog.New(os.Stdout).With().
		Timestamp().
		Str("service", "test").
		Logger()

	ctx = testLogger.WithContext(ctx)
	return ctx
}

// GetAPIURL returns the base URL for the API service
func GetAPIURL(port string) string {
	return fmt.Sprintf("http://localhost:%s", port)
}

// APIPort returns the API service port
func APIPort() string {
	ensureTestEnvInitialized()
	return appConfig.APIPort()
}

// SysPort returns the system endpoint port
func SysPort() string {
	ensureTestEnvInitialized()
	return appConfig.SysPort()
}
