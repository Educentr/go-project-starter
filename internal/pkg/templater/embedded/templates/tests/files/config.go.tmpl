// Code generated by go-project-starter. DO NOT EDIT.
package tests

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"time"

	gtt "github.com/Educentr/goat"
	"github.com/Educentr/goat/services"
{{ if .Application.UseActiveRecord }}
	"github.com/Educentr/goat-services/psql"
{{ end }}
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.Services }}{{ range .Application.GoatTestsConfig.Services }}{{ if eq . "xray" }}
	"github.com/Educentr/goat-services/xray"
{{ end }}{{ end }}{{ end }}
	tests_pkg "{{ .ProjectPath }}/pkg/tests"
)

const (
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.BinaryPath }}
	testBinaryPath  = "{{ .Application.GoatTestsConfig.BinaryPath }}"
{{ else }}
	testBinaryPath  = "/tmp/{{ .Application.Name }}"
{{ end }}
	testServiceName = "{{ .ProjectName }}"
{{ $hasSys := false }}{{ $hasAPI := false }}{{ range $_, $tr := .Application.GetRestTransport }}{{ if eq $tr.Name "sys" }}{{ $hasSys = true }}
	testSysPort = "{{ $tr.Port }}"
{{ else if and (ne $tr.GeneratorType "ogen_client") (not $hasAPI) }}{{ $hasAPI = true }}
	testAPIPort = "{{ $tr.Port }}"
{{ end }}{{ end }}{{ if not $hasSys }}
	testSysPort = "8080" // default sys port
{{ end }}{{ if not $hasAPI }}
	testAPIPort = "8081" // default api port
{{ end }}
)

// {{ .ProjectName | Capitalize }}Config implements TestAppConfig for {{ .ProjectName }} service
type {{ .ProjectName | Capitalize }}Config struct{}

// New{{ .ProjectName | Capitalize }}Config creates a new configuration for {{ .ProjectName }}
func New{{ .ProjectName | Capitalize }}Config() *{{ .ProjectName | Capitalize }}Config {
	return &{{ .ProjectName | Capitalize }}Config{}
}

// --- ServiceConfig ---

func (c *{{ .ProjectName | Capitalize }}Config) ServiceName() string { return testServiceName }
func (c *{{ .ProjectName | Capitalize }}Config) APIPort() string     { return testAPIPort }
func (c *{{ .ProjectName | Capitalize }}Config) SysPort() string     { return testSysPort }

// --- ExecutorBuilder ---

// NewExecutor creates an Executor for {{ .ProjectName }} with full configuration
func (c *{{ .ProjectName | Capitalize }}Config) NewExecutor(env *gtt.Env, mockAddress string) *gtt.Executor {
	envVars := c.loadEnvVars()

{{ if .Application.UseActiveRecord }}
	// Configure PostgreSQL
	pg := services.MustGetTyped[*psql.Env](env.Manager(), "postgres")
	c.configureDB(envVars, pg)
{{ end }}
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.Services }}{{ range .Application.GoatTestsConfig.Services }}{{ if eq . "xray" }}
	// Configure Xray (optional)
	if xr, err := services.GetTyped[*xray.Env](env.Manager(), "xray"); err == nil {
		c.configureXray(envVars, xr)
	}
{{ end }}{{ end }}{{ end }}
	// Configure external services (mock)
	c.configureExternalServices(envVars, mockAddress)

	// Binary path from environment or default
	binaryPath := os.Getenv("TEST_BINARY_PATH")
	if binaryPath == "" {
		binaryPath = testBinaryPath
	}

	return gtt.NewExecutorBuilder(binaryPath).
		WithEnv(envVars).
		WithOutputFile(fmt.Sprintf("/tmp/{{ .ProjectName }}-test-%d.log", time.Now().Unix())).
		Build()
}

func (c *{{ .ProjectName | Capitalize }}Config) loadEnvVars() map[string]string {
	envFilePath := "etc/onlineconf/onlineconf.env"
	if _, err := os.Stat(envFilePath); err == nil {
		envVars, err := tests_pkg.LoadEnvFile(envFilePath)
		if err != nil {
			panic(fmt.Errorf("failed to load %s: %w", envFilePath, err))
		}
		envVars["ONLINECONFIG_FROM_ENV"] = "true"
		return envVars
	}

	fmt.Println("onlineconf.env not found, using TREE.conf")
	envVars, err := tests_pkg.ParseOnlineConfFile("etc/onlineconf/TREE.conf")
	if err != nil {
		panic(err)
	}
	envVars["ONLINECONFIG_FROM_ENV"] = "true"
	return envVars
}

{{ if .Application.UseActiveRecord }}
func (c *{{ .ProjectName | Capitalize }}Config) configureDB(envVars map[string]string, pg *psql.Env) {
	svc := c.ServiceName()
	envVars[fmt.Sprintf("OC_%s__db__main", svc)] = fmt.Sprintf("%s:%s", pg.DBHost, pg.DBPort)
	envVars[fmt.Sprintf("OC_%s__db__main__User", svc)] = pg.DBUser
	envVars[fmt.Sprintf("OC_%s__db__main__Password", svc)] = pg.DBPass
	envVars[fmt.Sprintf("OC_%s__db__main__name", svc)] = pg.DBName
	envVars[fmt.Sprintf("OC_%s__db__main__TLSEnable", svc)] = "0"
	envVars[fmt.Sprintf("OC_%s__db__main__DB", svc)] = pg.DBName
}
{{ end }}
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.Services }}{{ range .Application.GoatTestsConfig.Services }}{{ if eq . "xray" }}
func (c *{{ $.ProjectName | Capitalize }}Config) configureXray(envVars map[string]string, xr *xray.Env) {
	envVars[fmt.Sprintf("OC_%s__xray__endpoint", c.ServiceName())] = xr.EndpointURL
}
{{ end }}{{ end }}{{ end }}
func (c *{{ .ProjectName | Capitalize }}Config) configureExternalServices(envVars map[string]string, mockAddress string) {
	// Override with mock addresses for external services
	// Add your external service configuration here
	_ = envVars
	_ = mockAddress
}

// --- DatabaseMigrator ---

func (c *{{ .ProjectName | Capitalize }}Config) MigrationFiles() []string {
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.Migrations.Files }}
	return []string{
	{{- range .Application.GoatTestsConfig.Migrations.Files }}
		"{{ . }}",
	{{- end }}
	}
{{ else }}
	return []string{
		// Add your migration files here
	}
{{ end }}
}

func (c *{{ .ProjectName | Capitalize }}Config) MigrationsPath() string {
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.Migrations.Path }}
	projectRoot, _ := filepath.Abs(filepath.Join("..", "."))
	return filepath.Join(projectRoot, "{{ .Application.GoatTestsConfig.Migrations.Path }}")
{{ else }}
	projectRoot, _ := filepath.Abs(filepath.Join("..", "."))
	return filepath.Join(projectRoot, "etc", "database", "postgres")
{{ end }}
}

func (c *{{ .ProjectName | Capitalize }}Config) IsInitialized(ctx context.Context, db *sql.DB) (bool, error) {
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.Migrations.CheckTable }}
	var exists bool
	err := db.QueryRow(
		"SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = '{{ .Application.GoatTestsConfig.Migrations.CheckTable }}')",
	).Scan(&exists)
	return exists, err
{{ else }}
	// Implement your initialization check
	return false, nil
{{ end }}
}

// --- DataCleaner ---

func (c *{{ .ProjectName | Capitalize }}Config) TablesToTruncate() []string {
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.CleanupTables }}
	return []string{
	{{- range .Application.GoatTestsConfig.CleanupTables }}
		"{{ . }}",
	{{- end }}
	}
{{ else }}
	return []string{
		// Add tables to truncate between tests (order matters for FK)
	}
{{ end }}
}

// --- ActiveRecordConfig ---

func (c *{{ .ProjectName | Capitalize }}Config) ConfigMap(dbHost, dbPort, dbUser, dbPass, dbName string) map[string]interface{} {
	return map[string]interface{}{
		"/{{ .ProjectName }}/db/main":           fmt.Sprintf("%s:%s", dbHost, dbPort),
		"/{{ .ProjectName }}/db/main/User":      dbUser,
		"/{{ .ProjectName }}/db/main/Password":  dbPass,
		"/{{ .ProjectName }}/db/main/DB":        dbName,
		"/{{ .ProjectName }}/db/main/PoolSize":  int64(10),
		"/{{ .ProjectName }}/db/main/TLSEnable": false,
		"/{{ .ProjectName }}/db/main/Timeout":   5 * time.Second,
	}
}
