// Code generated by go-project-starter. DO NOT EDIT.
package tests

import (
{{ if .Application.UseActiveRecord }}
	"context"
	"database/sql"
{{ end }}
	"fmt"
	"time"

	gtt "github.com/Educentr/goat"
)

const (
{{ if and .Application.GoatTestsConfig .Application.GoatTestsConfig.BinaryPath }}
	testBinaryPath  = "{{ .Application.GoatTestsConfig.BinaryPath }}"
{{ else }}
	testBinaryPath  = "/tmp/{{ .Application.Name }}"
{{ end }}
	testServiceName = "{{ .ProjectName }}"
{{ range $_, $tr := .Application.GetRestTransport }}{{ if ne $tr.GeneratorType "ogen_client" }}
	test{{ $tr.Name | Capitalize }}Port = "{{ $tr.Port }}"
{{ end }}{{ end }}
)

var transportPorts = map[string]string{
{{ range $_, $tr := .Application.GetRestTransport }}{{ if ne $tr.GeneratorType "ogen_client" }}
	"{{ $tr.Name }}": test{{ $tr.Name | Capitalize }}Port,
{{ end }}{{ end }}
}

// {{ .ProjectName | Capitalize }}Config provides basic service configuration.
// User must create their own config struct that embeds this one and implements:
// - NewExecutor() - create executor with proper environment
// - ApplyMigrations() - apply database migrations
// - CleanupTables() - cleanup tables between tests
type {{ .ProjectName | Capitalize }}Config struct{}

// New{{ .ProjectName | Capitalize }}Config creates a new configuration for {{ .ProjectName }}
func New{{ .ProjectName | Capitalize }}Config() *{{ .ProjectName | Capitalize }}Config {
	return &{{ .ProjectName | Capitalize }}Config{}
}

// --- ServiceConfig ---

func (c *{{ .ProjectName | Capitalize }}Config) ServiceName() string { return testServiceName }
func (c *{{ .ProjectName | Capitalize }}Config) BinaryPath() string  { return testBinaryPath }

func (c *{{ .ProjectName | Capitalize }}Config) TransportPort(name string) string {
	if port, ok := transportPorts[name]; ok {
		return port
	}
	return ""
}

// --- ExecutorBuilder ---
// User MUST override this method in their own config struct

func (c *{{ .ProjectName | Capitalize }}Config) NewExecutor(env *gtt.Env, mockAddress string) *gtt.Executor {
	panic(`NewExecutor not implemented.

Create your own config struct in init.go that embeds {{ .ProjectName | Capitalize }}Config:

    type myTestConfig struct {
        *{{ .ProjectName | Capitalize }}Config
    }

    func (c *myTestConfig) NewExecutor(env *gtt.Env, mockAddress string) *gtt.Executor {
        envVars := loadEnvVars()  // implement this helper
        configureDB(envVars, env) // implement this helper
        // Add your custom configuration here (xray, external services, etc.)

        // Pass GOCOVERDIR for coverage collection (if set)
        if coverDir := os.Getenv("GOCOVERDIR"); coverDir != "" {
            envVars["GOCOVERDIR"] = coverDir
        }

        return gtt.NewExecutorBuilder(c.BinaryPath()).
            WithEnv(envVars).
            WithOutputFile(fmt.Sprintf("/tmp/{{ .ProjectName }}-test-%d.log", time.Now().Unix())).
            Build()
    }
`)
}

{{ if .Application.UseActiveRecord }}
// --- MigrationRunner ---
// User MUST override this method

func (c *{{ .ProjectName | Capitalize }}Config) ApplyMigrations(ctx context.Context, db *sql.DB) error {
	panic(`ApplyMigrations not implemented.

Override this method in your config struct in init.go:

    func (c *myTestConfig) ApplyMigrations(ctx context.Context, db *sql.DB) error {
        migrationsPath := filepath.Join("..", "etc/database/postgres")
        migrationFiles := []string{
            "01_types.sql",
            "02_schema.sql",
            // ... your migration files
        }

        for _, file := range migrationFiles {
            content, err := os.ReadFile(filepath.Join(migrationsPath, file))
            if err != nil {
                return fmt.Errorf("read migration %s: %w", file, err)
            }
            if _, err := db.ExecContext(ctx, string(content)); err != nil {
                return fmt.Errorf("apply migration %s: %w", file, err)
            }
        }
        return nil
    }
`)
}

// --- TableCleaner ---
// User MUST override this method

func (c *{{ .ProjectName | Capitalize }}Config) CleanupTables(ctx context.Context, db *sql.DB) error {
	panic(`CleanupTables not implemented.

Override this method in your config struct in init.go:

    func (c *myTestConfig) CleanupTables(ctx context.Context, db *sql.DB) error {
        tables := []string{
            "sessions",
            "app_user",
            // ... your tables in FK-safe order
        }

        for _, table := range tables {
            if _, err := db.ExecContext(ctx, "TRUNCATE TABLE "+table+" CASCADE"); err != nil {
                return fmt.Errorf("truncate %s: %w", table, err)
            }
        }
        return nil
    }
`)
}

// --- ActiveRecordConfig ---

func (c *{{ .ProjectName | Capitalize }}Config) ConfigMap(dbHost, dbPort, dbUser, dbPass, dbName string) map[string]interface{} {
	return map[string]interface{}{
		"/{{ .ProjectName }}/db/main":           fmt.Sprintf("%s:%s", dbHost, dbPort),
		"/{{ .ProjectName }}/db/main/User":      dbUser,
		"/{{ .ProjectName }}/db/main/Password":  dbPass,
		"/{{ .ProjectName }}/db/main/DB":        dbName,
		"/{{ .ProjectName }}/db/main/PoolSize":  int64(10),
		"/{{ .ProjectName }}/db/main/TLSEnable": false,
		"/{{ .ProjectName }}/db/main/Timeout":   5 * time.Second,
	}
}
{{ end }}
