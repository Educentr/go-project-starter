package mw

import (
	"context"
	"net/http"
	"runtime/debug"
	"fmt"
	"strings"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}

	"{{ .ProjectPath }}/pkg/ds"
	"{{ .ProjectPath }}/pkg/reqctx"
	"{{ .ProjectPath }}/pkg/app/rest"
)

type DefaultMiddlewares struct{}
type EmptyMiddlewares struct{}

func (dmw *DefaultMiddlewares) GetMiddlewares(
	ctx context.Context,
	appName string,
	metrics *prometheus.Registry,
	srv ds.IService,
	serviceName string,
	errHdl rest.RestErrorHandler,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	// Мидлвари работают в том порядке в котором они находятся в этом массиве
	// Изменение порядка может сильно повлиять на работу сервиса, делать это надо только если вы уверенны что происходит
	mws := []func(next http.Handler) http.Handler{
		// Создаём контекст запроса
		func(next http.Handler) http.Handler {
			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				ctx, cancel := reqctx.CreateContext(ctx, ctx, onlineconf.MakePath(appName, "/transport/rest/", serviceName, "handler"), r.URL.Path)
				{{ .Logger.UpdateContext "ctx" "Str(\"Method\", r.Method)" "Str(\"URI\", r.RequestURI)" }}
				next.ServeHTTP(w, r.WithContext(ctx))
				cancel()
			})
		},
		PanicRecoveryMiddleware(ctx),								// Обработка паник
		HTTPServerMiddlewareRequestStartTime(),                     // Обогащаем контекст временем начала запроса
		HTTPServerMiddlewareTracing(ctx),                           // Обогащаем контекст запроса ID для трейсинга
		HTTPServerMiddlewareMetrics(ctx, serviceName, metrics, srv),// Инициализируем метрики, добавляем инфу о времени старта обработки запроса и т.д.
		HTTPServerMiddlewareXServerHeader(ctx, serviceName),        // Обогащаем ответ заголовком X-Server
	}

	httpAuthEnable, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/httpAuth/enabled", true)
	if err != nil {
		return nil, fmt.Errorf("error get httpAuth enabled: %w", err)
	}

	if httpAuthEnable {
		mws = append(mws, HTTPServerMiddlewareAuth(ctx, srv.GetAuthorizer(), errHdl))
	}

	csrfEnabled, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/csrf/enabled", false)
	if err != nil {
		return nil, fmt.Errorf("error get csrf enabled: %w", err)
	}

	if csrfEnabled {
		mws = append(mws, HTTPServerMiddlewareCSRF(ctx, srv.GetAuthorizer(), errHdl))
	}

	return mws, nil
}

func (emw *EmptyMiddlewares) GetMiddlewares(
	_ context.Context,
	_ string,
	_ *prometheus.Registry,
	_ ds.IService,
	_ string,
	_ rest.RestErrorHandler,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	return []func(next http.Handler) http.Handler{}, nil
}

func PanicRecoveryMiddleware(ctx context.Context) func (next http.Handler) http.Handler {
	return func (next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer func() {
				if err := recover(); err != nil {
					{{ .Logger.ErrorMsg "r.Context()" "nil" "Panic recovered" "Str(\"Stack\", strings.Replace(strings.Replace(string(debug.Stack()), \"\\n\\t/\", \" --> /\", -1), \"\\n\", \" => \", -1))" "Interface(\"Error\", err)" }}
					http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				}
			}()
			
			next.ServeHTTP(w, r)
		})
	}
}
