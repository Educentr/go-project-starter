package mw

import (
	"context"
	"net/http"
	"runtime/debug"
	"fmt"
	"strings"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}

	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
	"github.com/Educentr/go-project-starter-runtime/pkg/logger"
	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
	"{{ .ProjectPath }}/pkg/app/rest"
)

type DefaultMiddlewares struct{}
type EmptyMiddlewares struct{}

// GetMiddlewares returns middleware chain for REST server.
// Parameters:
// - appName: Application.Name (e.g., "web-app") - the specific application instance
// - serviceName: Main.Name (e.g., "my-api") - the service-level name (constant.ServiceName)
// - transportName: Transport.Name (e.g., "api_v1") - the REST transport name
func (dmw *DefaultMiddlewares) GetMiddlewares(
	ctx context.Context,
	appName string,
	metrics *prometheus.Registry,
	srv ds.IService,
	serviceName, transportName string,
	errHdl rest.RestErrorHandler,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	// Мидлвари работают в том порядке в котором они находятся в этом массиве
	// Изменение порядка может сильно повлиять на работу сервиса, делать это надо только если вы уверенны что происходит
	mws := []func(next http.Handler) http.Handler{
		// Создаём контекст запроса
		func(next http.Handler) http.Handler {
			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				// OnlineConf path hierarchy (3 levels):
				// 1. /{serviceName}/transport/rest/{transportName}/{appName}/handler/{path} - app-specific
				// 2. /{serviceName}/transport/rest/{transportName}/handler/{path} - transport-level
				// The path is resolved in CreateContext with fallback logic
				ocPrefix := onlineconf.MakePath(serviceName, "transport/rest", transportName, appName, "handler")
				// r.Context() - контекст запроса (основной), ctx - контекст приложения (для onlineconf)
				reqCtx, cancel, err := reqctx.CreateContext(r.Context(), ctx, ocPrefix, r.URL.Path)
				if err != nil {
					{{ .Logger.ErrorMsg "r.Context()" "err" "Failed to create request context" }}
					http.Error(w, "Internal Server Error", http.StatusInternalServerError)
					return
				}
				{{ .Logger.ReWrap "ctx" "reqCtx" "ocPrefix" "r.URL.Path" }}
				{{ .Logger.UpdateContext "reqCtx" "str::Method::r.Method" "str::URI::r.RequestURI" }}
				next.ServeHTTP(w, r.WithContext(reqCtx))
				cancel()
			})
		},
		PanicRecoveryMiddleware(ctx),                                               // Обработка паник
		HTTPServerMiddlewareRequestStartTime(),                                     // Обогащаем контекст временем начала запроса
		HTTPServerMiddlewareTracing(ctx),                                           // Обогащаем контекст запроса ID для трейсинга
		HTTPServerMiddlewareMetrics(ctx, serviceName, transportName, appName, metrics, srv), // Инициализируем метрики
		HTTPServerMiddlewareXServerHeader(ctx, appName),                            // Обогащаем ответ заголовком X-Server (с appName)
	}

	httpAuthEnable, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/httpAuth/enabled", true)
	if err != nil {
		return nil, fmt.Errorf("error get httpAuth enabled: %w", err)
	}

	if httpAuthEnable {
		mws = append(mws, HTTPServerMiddlewareAuth(ctx, srv.GetAuthorizer(), errHdl))
	}

	csrfEnabled, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/csrf/enabled", false)
	if err != nil {
		return nil, fmt.Errorf("error get csrf enabled: %w", err)
	}

	if csrfEnabled {
		mws = append(mws, HTTPServerMiddlewareCSRF(ctx, srv.GetAuthorizer(), errHdl))
	}

	return mws, nil
}

func (emw *EmptyMiddlewares) GetMiddlewares(
	_ context.Context,
	_ string,
	_ *prometheus.Registry,
	_ ds.IService,
	_, _ string,
	_ rest.RestErrorHandler,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	return []func(next http.Handler) http.Handler{}, nil
}

func PanicRecoveryMiddleware(ctx context.Context) func (next http.Handler) http.Handler {
	return func (next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer func() {
				if err := recover(); err != nil {
					{{ .Logger.ErrorMsg "r.Context()" "nil" "Panic recovered" "str::Stack::strings.Replace(strings.Replace(string(debug.Stack()), \"\\n\\t/\", \" --> /\", -1), \"\\n\", \" => \", -1)" "any::Error::err" }}
					http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				}
			}()
			
			next.ServeHTTP(w, r)
		})
	}
}
