package mw

import (
	"context"
	"net/http"
	"runtime/debug"
	"fmt"
	"strings"
	"time"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}

	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
{{ if ne (.Logger.FilesToGenerate) "logrus" }}	"github.com/Educentr/go-project-starter-runtime/pkg/logger"
{{ end }}	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
	"{{ .ProjectPath }}/pkg/app/rest"
)

type DefaultMiddlewares struct{}
type EmptyMiddlewares struct{}

// GetMiddlewares returns middleware chain for REST server.
// Parameters:
// - appName: Application.Name (e.g., "web-app") - the specific application instance
// - serviceName: Main.Name (e.g., "my-api") - the service-level name (constant.ServiceName)
// - transportName: Transport.Name (e.g., "api_v1") - the REST transport name
// - getWriteTimeout: returns current server WriteTimeout for handler timeout validation
func (dmw *DefaultMiddlewares) GetMiddlewares(
	ctx context.Context,
	appName string,
	metrics *prometheus.Registry,
	srv ds.IService,
	serviceName, transportName string,
	errHdl rest.RestErrorHandler,
	getWriteTimeout func() time.Duration,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	// Мидлвари работают в том порядке в котором они находятся в этом массиве
	// Изменение порядка может сильно повлиять на работу сервиса, делать это надо только если вы уверенны что происходит
	mws := []func(next http.Handler) http.Handler{
		// Создаём контекст запроса
		func(next http.Handler) http.Handler {
			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				// Combine method + path for OnlineConf key (e.g., GET_payment__token)
				pathKey := r.Method + "_" + strings.ReplaceAll(strings.TrimPrefix(r.URL.Path, "/"), "/", "__")

				// 3-level handler timeout fallback:
				// 1. App-specific: /{svc}/transport/rest/{transport}/{app}/handler/{pathKey}/timeout
				// 2. Transport-level: /{svc}/transport/rest/{transport}/handler/{pathKey}/timeout
				// 3. Default from code: defaultHandlerTimeout
				handlerTimeout := resolveHandlerTimeout(ctx, serviceName, transportName, appName, pathKey)

				// Validate: handler timeout must be <= write timeout
				writeTimeout := getWriteTimeout()
				if writeTimeout > 0 && handlerTimeout > writeTimeout {
					{{ .Logger.WarnMsg "r.Context()" "handler timeout exceeds write timeout, clamping" "str::handler_timeout::handlerTimeout.String()" "str::write_timeout::writeTimeout.String()" "str::path::r.URL.Path" }}
					handlerTimeout = writeTimeout
				}

				// r.Context() - контекст запроса (основной), ctx - контекст приложения (для onlineconf)
				reqCtx, cancel, err := reqctx.CreateContextWithTimeout(r.Context(), ctx, handlerTimeout)
				if err != nil {
					{{ .Logger.ErrorMsg "r.Context()" "err" "Failed to create request context" }}
					http.Error(w, "Internal Server Error", http.StatusInternalServerError)
					return
				}
				ocPrefix := onlineconf.MakePath(serviceName, "transport/rest", transportName, appName, "handler")
				{{ .Logger.ReWrap "ctx" "reqCtx" "ocPrefix" "pathKey" }}
				{{ .Logger.UpdateContext "reqCtx" "str::Method::r.Method" "str::URI::r.RequestURI" }}
				next.ServeHTTP(w, r.WithContext(reqCtx))
				cancel()
			})
		},
		PanicRecoveryMiddleware(ctx),                                               // Обработка паник
		HTTPServerMiddlewareRequestStartTime(),                                     // Обогащаем контекст временем начала запроса
		HTTPServerMiddlewareTracing(ctx),                                           // Обогащаем контекст запроса ID для трейсинга
		HTTPServerMiddlewareMetrics(ctx, serviceName, transportName, appName, metrics, srv), // Инициализируем метрики
		HTTPServerMiddlewareXServerHeader(ctx, appName),                            // Обогащаем ответ заголовком X-Server (с appName)
	}

	httpAuthEnable, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/httpAuth/enabled", true)
	if err != nil {
		return nil, fmt.Errorf("error get httpAuth enabled: %w", err)
	}

	if httpAuthEnable {
		mws = append(mws, HTTPServerMiddlewareAuth(ctx, srv.GetAuthorizer(), errHdl))
	}

	csrfEnabled, err := onlineconf.GetBool(ctx, "/{{ .ProjectName }}/security/csrf/enabled", false)
	if err != nil {
		return nil, fmt.Errorf("error get csrf enabled: %w", err)
	}

	if csrfEnabled {
		mws = append(mws, HTTPServerMiddlewareCSRF(ctx, srv.GetAuthorizer(), errHdl))
	}

	return mws, nil
}

func (emw *EmptyMiddlewares) GetMiddlewares(
	_ context.Context,
	_ string,
	_ *prometheus.Registry,
	_ ds.IService,
	_, _ string,
	_ rest.RestErrorHandler,
	_ func() time.Duration,
) (
	[]func(next http.Handler) http.Handler,
	error,
) {
	return []func(next http.Handler) http.Handler{}, nil
}

// resolveHandlerTimeout resolves handler timeout using 3-level fallback:
// 1. Per-path app-specific: /{svc}/transport/rest/{transport}/{app}/handler/{urlPath}/timeout
// 2. Per-path transport-level: /{svc}/transport/rest/{transport}/handler/{urlPath}/timeout
// 3. Default app-specific: /{svc}/transport/rest/{transport}/{app}/handler/default/timeout
// 4. Default transport-level: /{svc}/transport/rest/{transport}/handler/default/timeout
// 5. Code default: rest.defaultHandlerTimeout
func resolveHandlerTimeout(ctx context.Context, serviceName, transportName, appName, urlPath string) time.Duration {
	// Per-path timeout (most specific)
	for _, prefix := range []string{
		onlineconf.MakePath(serviceName, "transport/rest", transportName, appName, "handler"),
		onlineconf.MakePath(serviceName, "transport/rest", transportName, "handler"),
	} {
		path := onlineconf.MakePath(prefix, urlPath, "timeout")
		if t, ex, err := onlineconf.GetDurationIfExists(ctx, path); err == nil && ex {
			return t
		}
	}

	// Default handler timeout
	for _, prefix := range []string{
		onlineconf.MakePath(serviceName, "transport/rest", transportName, appName, "handler"),
		onlineconf.MakePath(serviceName, "transport/rest", transportName, "handler"),
	} {
		path := onlineconf.MakePath(prefix, "default/timeout")
		if t, ex, err := onlineconf.GetDurationIfExists(ctx, path); err == nil && ex {
			return t
		}
	}

	return rest.DefaultHandlerTimeout()
}

func PanicRecoveryMiddleware(ctx context.Context) func (next http.Handler) http.Handler {
	return func (next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer func() {
				if err := recover(); err != nil {
					{{ .Logger.ErrorMsg "r.Context()" "nil" "Panic recovered" "str::Stack::strings.Replace(strings.Replace(string(debug.Stack()), \"\\n\\t/\", \" --> /\", -1), \"\\n\", \" => \", -1)" "any::Error::err" }}
					http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				}
			}()
			
			next.ServeHTTP(w, r)
		})
	}
}
