package rest

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}
	"golang.org/x/sync/errgroup"
	
	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
)

type Server struct {
	// Имя транспорта
	name string

	// HTTP сервер
	httpSrv *http.Server

	// Сервис с бизнес логикой приложения
	srv ds.IService

	// АПИ как презентационный уровень для сервиса
	router Router
}

const (
	nameFieldLogger = "Name"
)

func (s *Server) Initialization(ctx context.Context) error {
	return nil
}

func GetConfigValue[T string|time.Duration](ctx context.Context, serviceName string, serverName string, appName string, key string, defaultVal *T, res *T) error {
	for _, path := range []string{
		onlineconf.MakePath(serviceName, "transport/rest/", serverName, appName, key),
		onlineconf.MakePath(serviceName, "transport/rest/", serverName, key),
	} {
		var (
			ex  bool
			err error
		)

		switch resPtr := any(res).(type) {
		case *string:
			*resPtr, ex, err = onlineconf.GetStringIfExists(ctx, path)
		case *time.Duration:
			*resPtr, ex, err = onlineconf.GetDurationIfExists(ctx, path)
		default:
			return errors.New("unsupported type")
		}

		if err != nil {
			return err
		}

		if !ex {
			continue
		}

		return nil
	}

	if defaultVal == nil {
		return errors.New("port not found " + 
			onlineconf.MakePath(serviceName, "transport/rest/", serverName, appName, key) + 
			" and " + 
			onlineconf.MakePath(serviceName, "transport/rest/", serverName, key))
	}

	*res = *defaultVal

	return nil
}

func (s *Server) GetHTTPServer(ctx context.Context, serviceName string, appName string) (*http.Server, error) {
	var (
		ip string
		port string
		timeout time.Duration
		headerTimeout time.Duration
	)

	err := GetConfigValue(ctx, serviceName, s.Name(), appName, "ip", &defaultListenIP, &ip)
	if err != nil {
		ip = defaultListenIP

		{{ .Logger.ErrorMsg "ctx" "err" "error getting ip from onlineconf" "Str(\"Default\", defaultListenIP)" }}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "port", nil, &port)
	if err != nil {
		return nil, fmt.Errorf("error get port: %w", err)
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "timeout", &defaultHTTPTimeout, &timeout)
	if err != nil {
		timeout = defaultHTTPTimeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting timeout from onlineconf" "Str(\"Default\", defaultHTTPTimeout.String())"}}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "timeout_read_header", &timeout, &headerTimeout)
	if err != nil {
		headerTimeout = timeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting timeout read header from onlineconf. Set to timeout"}}
	}

	// ToDo split timeout for read and write
	return &http.Server{
		Addr:              ip + ":" + port,
		WriteTimeout:      timeout * 2,
		ReadTimeout:       timeout,
		IdleTimeout:       timeout,
		ReadHeaderTimeout: headerTimeout,
	}, nil
}

func NewServer(name string, router Router) *Server {
	return &Server{
		name:   name,
		router: router,
	}
}

func (s *Server) Name() string {
	return s.name
}

func (s *Server) Init(ctx context.Context, serviceName, appName string, metrics *prometheus.Registry, srv ds.IService) error {
	var err error

	s.srv = srv

	s.httpSrv, err = s.GetHTTPServer(ctx, serviceName, appName)
	if err != nil {
		return errors.Wrap(err, "http server initialization")
	}

	err = s.router.InitRouters(ctx, s.httpSrv, s.srv, metrics)
	if err != nil {
		return errors.Wrap(err, "error initialization API Routers")
	}

	// GetMiddlewares parameters:
	// - appName: Application.Name (e.g., "web-app")
	// - serviceName: Main.Name (constant.ServiceName, e.g., "my-api")
	// - s.Name(): Transport.Name (e.g., "api_v1")
	mws, err := s.router.GetMiddlewares(ctx, appName, metrics, srv, serviceName, s.Name(), s.router.GetErrorHandler())
	if err != nil {
		return errors.Wrap(err, "error initialization API middlewares")
	}

	for i := len(mws); i > 0; i-- {
		s.httpSrv.Handler = mws[i-1](s.httpSrv.Handler)
	}

	return nil
}

func (s *Server) Run(ctx context.Context, errGr *errgroup.Group) {
	{{ .Logger.InfoMsg "ctx" "Run rest server" "Str(nameFieldLogger, s.name)"}}

	// initialization http server
	errGr.Go(func() error {
		{{ .Logger.InfoMsg "ctx" "server started serving" "Str(\"addr\", s.httpSrv.Addr)" "Str(nameFieldLogger, s.name)" }}

		err := s.httpSrv.ListenAndServe()
		if err != nil {
			if errors.Is(err, http.ErrServerClosed) {
				return nil
			}

			{{ .Logger.ErrorMsg "ctx" "err).Str(nameFieldLogger, s.name" "server initialization/runtime error"}}
		}

		return err
	})
}
