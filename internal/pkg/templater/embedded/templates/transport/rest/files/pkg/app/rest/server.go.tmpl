package rest

import (
	"context"
	"fmt"
	"net/http"
	"sync"
	"sync/atomic"
	"time"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}
	"golang.org/x/sync/errgroup"

	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
)

type Server struct {
	// Имя транспорта
	name string

	// HTTP сервер
	httpSrv *http.Server

	// Сервис с бизнес логикой приложения
	srv ds.IService

	// АПИ как презентационный уровень для сервиса
	router Router

	// Для динамического обновления таймаутов через OnlineConf.
	// Таймауты хранятся в atomic-полях, а не в http.Server напрямую,
	// т.к. net/http читает поля Server без синхронизации.
	// При изменении таймаутов — graceful restart http.Server.
	serviceName       string
	appName           string
	readTimeout       atomic.Int64 // наносекунды
	writeTimeout      atomic.Int64 // наносекунды
	idleTimeout       atomic.Int64 // наносекунды
	readHeaderTimeout atomic.Int64 // наносекунды

	// Для пересоздания сервера при изменении таймаутов
	mu           sync.Mutex          // защита httpSrv при замене
	errGr        *errgroup.Group     // из Run(), для запуска нового сервера
	shuttingDown atomic.Bool         // true = финальный shutdown, не перезапускать
}

const (
	nameFieldLogger = "Name"
)

func (s *Server) Initialization(ctx context.Context) error {
	return nil
}

func GetConfigValue[T string|time.Duration](ctx context.Context, serviceName string, serverName string, appName string, key string, defaultVal *T, res *T) error {
	for _, path := range []string{
		onlineconf.MakePath(serviceName, "transport/rest/", serverName, appName, key),
		onlineconf.MakePath(serviceName, "transport/rest/", serverName, key),
	} {
		var (
			ex  bool
			err error
		)

		switch resPtr := any(res).(type) {
		case *string:
			*resPtr, ex, err = onlineconf.GetStringIfExists(ctx, path)
		case *time.Duration:
			*resPtr, ex, err = onlineconf.GetDurationIfExists(ctx, path)
		default:
			return errors.New("unsupported type")
		}

		if err != nil {
			return err
		}

		if !ex {
			continue
		}

		return nil
	}

	if defaultVal == nil {
		return errors.New("port not found " + 
			onlineconf.MakePath(serviceName, "transport/rest/", serverName, appName, key) + 
			" and " + 
			onlineconf.MakePath(serviceName, "transport/rest/", serverName, key))
	}

	*res = *defaultVal

	return nil
}

func (s *Server) GetHTTPServer(ctx context.Context, serviceName string, appName string) (*http.Server, error) {
	var (
		ip            string
		port          string
		timeoutRead   time.Duration
		timeoutWrite  time.Duration
		headerTimeout time.Duration
	)

	err := GetConfigValue(ctx, serviceName, s.Name(), appName, "ip", &defaultListenIP, &ip)
	if err != nil {
		ip = defaultListenIP

		{{ .Logger.ErrorMsg "ctx" "err" "error getting ip from onlineconf" "str::Default::defaultListenIP" }}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "port", nil, &port)
	if err != nil {
		return nil, fmt.Errorf("error get port: %w", err)
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "server/timeout/read", &defaultHTTPReadTimeout, &timeoutRead)
	if err != nil {
		timeoutRead = defaultHTTPReadTimeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting server/timeout/read from onlineconf" "str::Default::defaultHTTPReadTimeout.String()"}}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "server/timeout/write", &defaultHTTPWriteTimeout, &timeoutWrite)
	if err != nil {
		timeoutWrite = defaultHTTPWriteTimeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting server/timeout/write from onlineconf" "str::Default::defaultHTTPWriteTimeout.String()"}}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "server/timeout/read_header", &timeoutRead, &headerTimeout)
	if err != nil {
		headerTimeout = timeoutRead

		{{ .Logger.ErrorMsg "ctx" "err" "error getting server/timeout/read_header from onlineconf. Set to server/timeout/read"}}
	}

	s.readTimeout.Store(int64(timeoutRead))
	s.writeTimeout.Store(int64(timeoutWrite))
	s.idleTimeout.Store(int64(timeoutRead))
	s.readHeaderTimeout.Store(int64(headerTimeout))

	return &http.Server{
		Addr:              ip + ":" + port,
		WriteTimeout:      timeoutWrite,
		ReadTimeout:       timeoutRead,
		IdleTimeout:       timeoutRead,
		ReadHeaderTimeout: headerTimeout,
	}, nil
}

func NewServer(name string, router Router) *Server {
	return &Server{
		name:   name,
		router: router,
	}
}

func (s *Server) Name() string {
	return s.name
}

func (s *Server) Init(ctx context.Context, serviceName, appName string, metrics *prometheus.Registry, srv ds.IService) error {
	var err error

	s.srv = srv
	s.serviceName = serviceName
	s.appName = appName

	s.httpSrv, err = s.GetHTTPServer(ctx, serviceName, appName)
	if err != nil {
		return errors.Wrap(err, "http server initialization")
	}

	// Subscribe to timeout changes in OnlineConf
	timeoutPaths := []string{
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), appName, "server/timeout/read"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), "server/timeout/read"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), appName, "server/timeout/write"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), "server/timeout/write"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), appName, "server/timeout/read_header"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), "server/timeout/read_header"),
	}

	err = onlineconf.RegisterSubscription(ctx, onlineconf.DefaultModule, timeoutPaths, func() error {
		s.updateTimeouts(ctx)
		return nil
	})
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "failed to register timeout subscription"}}
	}

	err = s.router.InitRouters(ctx, s.httpSrv, s.srv, metrics)
	if err != nil {
		return errors.Wrap(err, "error initialization API Routers")
	}

	// GetMiddlewares parameters:
	// - appName: Application.Name (e.g., "web-app")
	// - serviceName: Main.Name (constant.ServiceName, e.g., "my-api")
	// - s.Name(): Transport.Name (e.g., "api_v1")
	mws, err := s.router.GetMiddlewares(ctx, appName, metrics, srv, serviceName, s.Name(), s.router.GetErrorHandler(), s.GetWriteTimeout)
	if err != nil {
		return errors.Wrap(err, "error initialization API middlewares")
	}

	for i := len(mws); i > 0; i-- {
		s.httpSrv.Handler = mws[i-1](s.httpSrv.Handler)
	}

	return nil
}

func (s *Server) updateTimeouts(ctx context.Context) {
	var timeoutRead, timeoutWrite, headerTimeout time.Duration

	_ = GetConfigValue(ctx, s.serviceName, s.Name(), s.appName, "server/timeout/read", &defaultHTTPReadTimeout, &timeoutRead)
	_ = GetConfigValue(ctx, s.serviceName, s.Name(), s.appName, "server/timeout/write", &defaultHTTPWriteTimeout, &timeoutWrite)
	_ = GetConfigValue(ctx, s.serviceName, s.Name(), s.appName, "server/timeout/read_header", &timeoutRead, &headerTimeout)

	// Сравниваем с текущими значениями
	changed := s.readTimeout.Load() != int64(timeoutRead) ||
		s.writeTimeout.Load() != int64(timeoutWrite) ||
		s.readHeaderTimeout.Load() != int64(headerTimeout)

	// Обновляем atomic-поля немедленно (middleware видит новые значения сразу)
	s.readTimeout.Store(int64(timeoutRead))
	s.writeTimeout.Store(int64(timeoutWrite))
	s.idleTimeout.Store(int64(timeoutRead))
	s.readHeaderTimeout.Store(int64(headerTimeout))

	{{ .Logger.InfoMsg "ctx" "REST server timeouts updated" "str::$nameFieldLogger::s.name" "str::server_timeout_read::timeoutRead.String()" "str::server_timeout_write::timeoutWrite.String()" "str::server_timeout_read_header::headerTimeout.String()" }}

	if changed && s.errGr != nil {
		go s.restartServer(ctx)
	}
}

// GetWriteTimeout returns the current server WriteTimeout for handler timeout validation.
func (s *Server) GetWriteTimeout() time.Duration {
	return time.Duration(s.writeTimeout.Load())
}

// GetReadTimeout returns the current server ReadTimeout.
func (s *Server) GetReadTimeout() time.Duration {
	return time.Duration(s.readTimeout.Load())
}

func (s *Server) Run(ctx context.Context, errGr *errgroup.Group) {
	s.errGr = errGr

	{{ .Logger.InfoMsg "ctx" "Run rest server" "str::$nameFieldLogger::s.name"}}

	// initialization http server
	errGr.Go(func() error {
		{{ .Logger.InfoMsg "ctx" "server started serving" "str::addr::s.httpSrv.Addr" "str::$nameFieldLogger::s.name" }}

		err := s.httpSrv.ListenAndServe()
		if err != nil && !errors.Is(err, http.ErrServerClosed) {
			{{ .Logger.ErrorMsg "ctx" "err" "server initialization/runtime error" "str::$nameFieldLogger::s.name"}}
			return err
		}

		return nil
	})
}

func (s *Server) restartServer(ctx context.Context) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.shuttingDown.Load() {
		return
	}

	newSrv := &http.Server{
		Addr:              s.httpSrv.Addr,
		Handler:           s.httpSrv.Handler,
		WriteTimeout:      time.Duration(s.writeTimeout.Load()),
		ReadTimeout:       time.Duration(s.readTimeout.Load()),
		IdleTimeout:       time.Duration(s.idleTimeout.Load()),
		ReadHeaderTimeout: time.Duration(s.readHeaderTimeout.Load()),
	}

	// Graceful shutdown старого сервера: закрывает listener, ждёт завершения активных соединений
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := s.httpSrv.Shutdown(shutdownCtx); err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "server shutdown error during restart" }}
	}

	s.httpSrv = newSrv

	s.errGr.Go(func() error {
		{{ .Logger.InfoMsg "ctx" "server restarted with new timeouts" "str::addr::newSrv.Addr" "str::$nameFieldLogger::s.name" }}

		err := newSrv.ListenAndServe()
		if err != nil && !errors.Is(err, http.ErrServerClosed) {
			{{ .Logger.ErrorMsg "ctx" "err" "server error after restart" "str::$nameFieldLogger::s.name" }}
			return err
		}

		return nil
	})
}
