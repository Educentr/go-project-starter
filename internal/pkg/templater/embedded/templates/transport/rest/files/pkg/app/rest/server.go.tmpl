package rest

import (
	"context"
	"fmt"
	"net/http"
	"sync/atomic"
	"time"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}
	"golang.org/x/sync/errgroup"

	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
)

type Server struct {
	// Имя транспорта
	name string

	// HTTP сервер
	httpSrv *http.Server

	// Сервис с бизнес логикой приложения
	srv ds.IService

	// АПИ как презентационный уровень для сервиса
	router Router

	// Для динамического обновления и доступа из middleware
	serviceName  string
	appName      string
	writeTimeout atomic.Int64 // наносекунды, для потокобезопасного чтения из middleware
}

const (
	nameFieldLogger = "Name"
)

func (s *Server) Initialization(ctx context.Context) error {
	return nil
}

func GetConfigValue[T string|time.Duration](ctx context.Context, serviceName string, serverName string, appName string, key string, defaultVal *T, res *T) error {
	for _, path := range []string{
		onlineconf.MakePath(serviceName, "transport/rest/", serverName, appName, key),
		onlineconf.MakePath(serviceName, "transport/rest/", serverName, key),
	} {
		var (
			ex  bool
			err error
		)

		switch resPtr := any(res).(type) {
		case *string:
			*resPtr, ex, err = onlineconf.GetStringIfExists(ctx, path)
		case *time.Duration:
			*resPtr, ex, err = onlineconf.GetDurationIfExists(ctx, path)
		default:
			return errors.New("unsupported type")
		}

		if err != nil {
			return err
		}

		if !ex {
			continue
		}

		return nil
	}

	if defaultVal == nil {
		return errors.New("port not found " + 
			onlineconf.MakePath(serviceName, "transport/rest/", serverName, appName, key) + 
			" and " + 
			onlineconf.MakePath(serviceName, "transport/rest/", serverName, key))
	}

	*res = *defaultVal

	return nil
}

func (s *Server) GetHTTPServer(ctx context.Context, serviceName string, appName string) (*http.Server, error) {
	var (
		ip            string
		port          string
		timeoutRead   time.Duration
		timeoutWrite  time.Duration
		headerTimeout time.Duration
	)

	err := GetConfigValue(ctx, serviceName, s.Name(), appName, "ip", &defaultListenIP, &ip)
	if err != nil {
		ip = defaultListenIP

		{{ .Logger.ErrorMsg "ctx" "err" "error getting ip from onlineconf" "str::Default::defaultListenIP" }}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "port", nil, &port)
	if err != nil {
		return nil, fmt.Errorf("error get port: %w", err)
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "timeout_read", &defaultHTTPReadTimeout, &timeoutRead)
	if err != nil {
		timeoutRead = defaultHTTPReadTimeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting timeout_read from onlineconf" "str::Default::defaultHTTPReadTimeout.String()"}}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "timeout_write", &defaultHTTPWriteTimeout, &timeoutWrite)
	if err != nil {
		timeoutWrite = defaultHTTPWriteTimeout

		{{ .Logger.ErrorMsg "ctx" "err" "error getting timeout_write from onlineconf" "str::Default::defaultHTTPWriteTimeout.String()"}}
	}

	err = GetConfigValue(ctx, serviceName, s.Name(), appName, "timeout_read_header", &timeoutRead, &headerTimeout)
	if err != nil {
		headerTimeout = timeoutRead

		{{ .Logger.ErrorMsg "ctx" "err" "error getting timeout_read_header from onlineconf. Set to timeout_read"}}
	}

	s.writeTimeout.Store(int64(timeoutWrite))

	return &http.Server{
		Addr:              ip + ":" + port,
		WriteTimeout:      timeoutWrite,
		ReadTimeout:       timeoutRead,
		IdleTimeout:       timeoutRead,
		ReadHeaderTimeout: headerTimeout,
	}, nil
}

func NewServer(name string, router Router) *Server {
	return &Server{
		name:   name,
		router: router,
	}
}

func (s *Server) Name() string {
	return s.name
}

func (s *Server) Init(ctx context.Context, serviceName, appName string, metrics *prometheus.Registry, srv ds.IService) error {
	var err error

	s.srv = srv
	s.serviceName = serviceName
	s.appName = appName

	s.httpSrv, err = s.GetHTTPServer(ctx, serviceName, appName)
	if err != nil {
		return errors.Wrap(err, "http server initialization")
	}

	// Subscribe to timeout changes in OnlineConf
	timeoutPaths := []string{
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), appName, "timeout_read"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), "timeout_read"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), appName, "timeout_write"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), "timeout_write"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), appName, "timeout_read_header"),
		onlineconf.MakePath(serviceName, "transport/rest/", s.Name(), "timeout_read_header"),
	}

	err = onlineconf.RegisterSubscription(ctx, onlineconf.DefaultModule, timeoutPaths, func() error {
		s.updateTimeouts(ctx)
		return nil
	})
	if err != nil {
		{{ .Logger.ErrorMsg "ctx" "err" "failed to register timeout subscription"}}
	}

	err = s.router.InitRouters(ctx, s.httpSrv, s.srv, metrics)
	if err != nil {
		return errors.Wrap(err, "error initialization API Routers")
	}

	// GetMiddlewares parameters:
	// - appName: Application.Name (e.g., "web-app")
	// - serviceName: Main.Name (constant.ServiceName, e.g., "my-api")
	// - s.Name(): Transport.Name (e.g., "api_v1")
	mws, err := s.router.GetMiddlewares(ctx, appName, metrics, srv, serviceName, s.Name(), s.router.GetErrorHandler(), s.GetWriteTimeout)
	if err != nil {
		return errors.Wrap(err, "error initialization API middlewares")
	}

	for i := len(mws); i > 0; i-- {
		s.httpSrv.Handler = mws[i-1](s.httpSrv.Handler)
	}

	return nil
}

func (s *Server) updateTimeouts(ctx context.Context) {
	var timeoutRead, timeoutWrite, headerTimeout time.Duration

	_ = GetConfigValue(ctx, s.serviceName, s.Name(), s.appName, "timeout_read", &defaultHTTPReadTimeout, &timeoutRead)
	_ = GetConfigValue(ctx, s.serviceName, s.Name(), s.appName, "timeout_write", &defaultHTTPWriteTimeout, &timeoutWrite)
	_ = GetConfigValue(ctx, s.serviceName, s.Name(), s.appName, "timeout_read_header", &timeoutRead, &headerTimeout)

	s.httpSrv.WriteTimeout = timeoutWrite
	s.httpSrv.ReadTimeout = timeoutRead
	s.httpSrv.IdleTimeout = timeoutRead
	s.httpSrv.ReadHeaderTimeout = headerTimeout
	s.writeTimeout.Store(int64(timeoutWrite))

	{{ .Logger.InfoMsg "ctx" "REST server timeouts updated" "str::$nameFieldLogger::s.name" "str::timeout_read::timeoutRead.String()" "str::timeout_write::timeoutWrite.String()" "str::timeout_read_header::headerTimeout.String()" }}
}

// GetWriteTimeout returns the current server WriteTimeout for handler timeout validation.
func (s *Server) GetWriteTimeout() time.Duration {
	return time.Duration(s.writeTimeout.Load())
}

func (s *Server) Run(ctx context.Context, errGr *errgroup.Group) {
	{{ .Logger.InfoMsg "ctx" "Run rest server" "str::$nameFieldLogger::s.name"}}

	// initialization http server
	errGr.Go(func() error {
		{{ .Logger.InfoMsg "ctx" "server started serving" "str::addr::s.httpSrv.Addr" "str::$nameFieldLogger::s.name" }}

		err := s.httpSrv.ListenAndServe()
		if err != nil {
			if errors.Is(err, http.ErrServerClosed) {
				return nil
			}

			{{ .Logger.ErrorMsg "ctx" "err" "server initialization/runtime error" "str::$nameFieldLogger::s.name"}}
		}

		return err
	})
}
