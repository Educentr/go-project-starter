package mw

import (
	"context"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/prometheus/client_golang/prometheus"
	{{ .Logger.Import }}
	"github.com/urfave/negroni"

	"github.com/Educentr/go-project-starter-runtime/pkg/logger"
	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
)

type HitInfoCallback interface {
	HitInfo(ctx context.Context, method string, u *url.URL, status int, contentLength int, ip string, contentType string, userAgent string, referer string, execTime float64)
}

// HTTPServerMiddlewareMetrics creates a middleware that collects HTTP request metrics.
// Parameters:
// - serviceName: Main.Name (e.g., "my-api") - used for Prometheus namespace
// - transportName: Transport.Name (e.g., "api_v1") - the REST transport name
// - appName: Application.Name (e.g., "web-app") - for app-specific OnlineConf paths
func HTTPServerMiddlewareMetrics(ctx context.Context, serviceName, transportName, appName string, metrics *prometheus.Registry, dwm HitInfoCallback) func(http.Handler) http.Handler {
	// Use serviceName for Prometheus namespace and transportName for subsystem (sanitized: replace - with _)
	// This ensures unique metric names when multiple REST transports exist
	// Metric name format: {namespace}_{subsystem}_{name}, e.g., my_api_api_v1_request_duration_seconds
	namespace := strings.ReplaceAll(serviceName, "-", "_")
	subsystem := strings.ReplaceAll(transportName, "-", "_")

	metricHTTP := prometheus.NewHistogramVec(prometheus.HistogramOpts{
		Namespace: namespace,
		Subsystem: subsystem,
		Name:      "request_duration_seconds",
		Help:      "The latency of the HTTP requests.",
		Buckets:   prometheus.DefBuckets,
	}, []string{"handler", "method", "code"})
	metrics.MustRegister(metricHTTP)

	requestCumulativeMetricsHist := prometheus.NewHistogramVec(prometheus.HistogramOpts{
		Namespace: namespace,
		Subsystem: subsystem,
		Name:      "cumulative_per_request_hist",
		Help:      "The cumulative latency metrics per request",
		Buckets:   prometheus.DefBuckets,
	}, []string{"requestName", "method", "code", "metric"})
	metrics.MustRegister(requestCumulativeMetricsHist)

	requestCumulativeMetricsCount := prometheus.NewCounterVec(prometheus.CounterOpts{
		Namespace: namespace,
		Subsystem: subsystem,
		Name:      "cumulative_per_request_count",
		Help:      "The cumulative count metrics per request",
	}, []string{"requestName", "method", "code", "metric"})
	metrics.MustRegister(requestCumulativeMetricsCount)

	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			{{ .Logger.InfoMsg "r.Context()" "Start request"
				"str::Method::r.Method"
				"str::Content-Length::r.Header.Get(\"content-length\")"
				"str::X-Real-IP::r.Header.Get(\"x-real-ip\")"
				"str::Content-Type::r.Header.Get(\"content-type\")"
				"str::User-Agent::r.Header.Get(\"user-agent\")"
				"str::Referer::r.Header.Get(\"referer\")"
			}}

			StartedAt := time.Now()

			var err error

			workCtx, err := reqctx.CreateCumulativeMetric(r.Context(), requestCumulativeMetricsHist, requestCumulativeMetricsCount)
			if err != nil {
				{{ .Logger.ErrorMsg "r.Context()" "err" "can't init per request cumulative metrics"}}
			}

			// TODO Обновить negroni на https://pkg.go.dev/net/http#NewResponseController
			rw := negroni.NewResponseWriter(w)
			r = r.WithContext(workCtx)
			next.ServeHTTP(rw, r)

			status := strconv.Itoa(rw.Status())

			reqctx.FlushCumulativeMetric(r.Context(), r.URL.Path, r.Method, status)

			execTime := time.Since(StartedAt).Seconds()
			metricHTTP.WithLabelValues(r.URL.Path, r.Method, status).Observe(execTime)

			userIP := ""

			posibleAddresses := []string{
				r.Header.Get("x-real-ip"),
				strings.Split(r.Header.Get("x-forwarded-for"), ",")[0],
				"0.0.0.0",
			}

			for _, ip := range posibleAddresses {
				if ip != "" {
					userIP = ip
					break
				}
			}

			// ToDo сделать колбек для создания новых контекстов по коду, где это может быть надо
			// либо сделать отдельную очередь на выпоплнение отложенных заданий после обработки пользовательских запросов
			// что бы не держать пользователя пока мы отправляем статистику
			// OnlineConf path: /{serviceName}/transport/rest/{transportName}/{appName}/mw/metrics
			ocPrefix := onlineconf.MakePath(serviceName, "transport/rest", transportName, appName, "mw/metrics")
			mwCtx, cancel, err := reqctx.CreateContext(r.Context(), ctx, ocPrefix, r.URL.Path)
			if err != nil {
				{{ .Logger.ErrorMsg "r.Context()" "err" "Failed to create context for HitInfo" }}
			} else {
				{{ .Logger.ReWrap "r.Context()" "mwCtx" "ocPrefix" "r.URL.Path" }}
				dwm.HitInfo(mwCtx, r.Method, r.URL, rw.Status(), rw.Size(), userIP, rw.Header().Get("Content-Type"), r.Header.Get("user-agent"), r.Header.Get("referer"), execTime)
				cancel()
			}

			statusCode := rw.Status()
			if statusCode >= 500 {
				{{ .Logger.ErrorMsg "r.Context()" "nil" "Done request"
					"int::Status::statusCode"
					"str::Method::r.Method"
					"int::Content-Length::rw.Size()"
					"str::X-Real-IP::userIP"
					"str::Content-Type::rw.Header().Get(\"Content-Type\")"
					"str::User-Agent::r.Header.Get(\"user-agent\")"
					"str::Referer::r.Header.Get(\"referer\")"
				}}
			} else if statusCode >= 400 {
				{{ .Logger.WarnMsg "r.Context()" "Done request"
					"int::Status::statusCode"
					"str::Method::r.Method"
					"int::Content-Length::rw.Size()"
					"str::X-Real-IP::userIP"
					"str::Content-Type::rw.Header().Get(\"Content-Type\")"
					"str::User-Agent::r.Header.Get(\"user-agent\")"
					"str::Referer::r.Header.Get(\"referer\")"
				}}
			} else {
				{{ .Logger.InfoMsg "r.Context()" "Done request"
					"int::Status::statusCode"
					"str::Method::r.Method"
					"int::Content-Length::rw.Size()"
					"str::X-Real-IP::userIP"
					"str::Content-Type::rw.Header().Get(\"Content-Type\")"
					"str::User-Agent::r.Header.Get(\"user-agent\")"
					"str::Referer::r.Header.Get(\"referer\")"
				}}
			}
		})
	}
}