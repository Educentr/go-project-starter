package {{ .Transport.Name }}

import (
	"context"
	"net/http"
	"time"

	{{ if not .Transport.IsDynamic -}}
	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	{{- end }}
	"github.com/pkg/errors"
	"go.opentelemetry.io/otel/attribute"

	"{{ .ProjectPath }}/internal/app/constant"
	"{{ .ProjectPath }}/pkg/app/rest"
	{{ .Transport.PkgName }} "{{ .ProjectPath }}/pkg/rest/{{ .Transport.Name }}/v1"
)
{{ if .Transport.IsDynamic }}
// NewDynamicClient creates a client for the given base URL.
// Use this when client endpoints are discovered at runtime.
func NewDynamicClient(ctx context.Context, baseURL string) (*{{ .Transport.PkgName }}.Client, error) {
	if baseURL == "" {
		return nil, errors.New("baseURL cannot be empty")
	}

	defaultClient := &rest.DefaultClient{}

	return {{ .Transport.PkgName }}.NewClient(
		baseURL,
		{{ if or (and (eq .Transport.AuthParams.Transport "header") (eq .Transport.AuthParams.Type "apikey")) (and (eq .Transport.AuthParams.Transport "header") (eq .Transport.AuthParams.Type "bearer")) -}}
		&SecuritySource{},
		{{ end -}}
		{{ .Transport.PkgName }}.WithClient(&http.Client{
			Timeout: time.Second * 30,
			Transport: rest.Chain(http.DefaultTransport,
				defaultClient.GetClientMiddlewares(ctx, constant.ServiceName, nil, nil, "{{ .Transport.PkgName }}", nil)...,
			),
		}),
		{{ .Transport.PkgName }}.WithAttributes(
			attribute.String("client_name", "{{ .Transport.Name }}"),
			attribute.String("service_name", constant.ServiceName),
		),
	)
}
{{ else }}
type Client struct {
	rest.DefaultClient
}

func NewClient() *Client {
	return &Client{}
}

// ClientName implements ds.ClientInitializer interface
func (c *Client) ClientName() string {
	return "{{ .Transport.Name }}"
}

func (c *Client) GetClient{{ .Transport.Name }}(ctx context.Context) (*{{ .Transport.PkgName }}.Client, error) {
	url, ex, err := onlineconf.GetStringIfExists(ctx, onlineconf.MakePath(constant.ServiceName, "transport", "rest", "{{ .Transport.PkgName }}", "host"))
	if err != nil {
		return nil, errors.Wrap(err, "error getting {{ .Transport.PkgName }} url")
	}

	if !ex || url == "" {
		{{ if .Applications.IsTransportOptional .Transport.Name -}}
		return nil, nil
		{{- else -}}
		return nil, errors.New("{{ .Transport.PkgName }} client URL not configured")
		{{- end }}
	}

	timeout, err := onlineconf.GetDuration(ctx, onlineconf.MakePath(constant.ServiceName, "transport", "rest", "{{ .Transport.PkgName }}", "timeout"), time.Second * 2)
	if err != nil {
		return nil, errors.Wrap(err, "error getting {{ .Transport.PkgName }} url")
	}

	return {{ .Transport.PkgName }}.NewClient(
		url,
        {{ if or (and (eq .Transport.AuthParams.Transport "header") (eq .Transport.AuthParams.Type "apikey")) (and (eq .Transport.AuthParams.Transport "header") (eq .Transport.AuthParams.Type "bearer")) }}
		&SecuritySource{},
        {{ end }}
		{{ .Transport.PkgName }}.WithClient(&http.Client{
			Timeout: timeout,
			Transport: rest.Chain(http.DefaultTransport,
				c.GetClientMiddlewares(ctx, constant.ServiceName, nil, nil, "{{ .Transport.PkgName }}", nil)...,
			),
		}),
		{{ .Transport.PkgName }}.WithAttributes(
			attribute.String("client_name", "{{ .Transport.Name }}"),
			attribute.String("service_name", constant.ServiceName),
		),
	)
}
{{ end }}
