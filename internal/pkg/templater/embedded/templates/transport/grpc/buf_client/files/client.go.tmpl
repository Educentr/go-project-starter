package {{ .Transport.Name }}

import (
	"context"
	"fmt"
	"time"

	{{ if not .Transport.IsDynamic -}}
	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	{{- end }}
	"github.com/pkg/errors"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	{{ .Logger.Import }}
)
{{ if .Transport.IsDynamic }}
const (
	defaultTimeout = 10 * time.Second
)

// NewDynamicClient creates a gRPC client connection for the given address.
// Use this when client endpoints are discovered at runtime.
func NewDynamicClient(ctx context.Context, address string) (*Client, error) {
	if address == "" {
		return nil, errors.New("address cannot be empty")
	}

	//nolint:staticcheck // grpc.DialContext is deprecated but provides better compatibility
	client, err := grpc.DialContext(ctx, address,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to create client for %s", address)
	}

	{{ .Logger.InfoMsg "ctx" "Created dynamic gRPC client" "str::address::address" }}

	return &Client{
		client: client,
	}, nil
}

// Client holds the initialized gRPC connection
type Client struct {
	client *grpc.ClientConn
}

func (c *Client) GetClient() *grpc.ClientConn {
	return c.client
}

func (c *Client) Close() error {
	if c.client != nil {
		return c.client.Close()
	}
	return nil
}
{{ else }}
// Client holds the initialized gRPC connection
type Client struct {
	client *grpc.ClientConn
}

// ClientWrapper is used for lazy initialization via SetClient pattern
type ClientWrapper struct{}

const (
	defaultTimeout = 10 * time.Second
)

// NewClient returns a wrapper for lazy initialization.
// The actual connection is created in Init().
func NewClient() *ClientWrapper {
	return &ClientWrapper{}
}

// ClientName implements ds.ClientInitializer interface
func (c *ClientWrapper) ClientName() string {
	return "{{ .Transport.Name }}"
}

// Init creates the actual gRPC connection
func (c *ClientWrapper) Init(ctx context.Context, serviceName string) (*Client, error) {
	var (
		host string
		port string
	)

	// Get configuration from OnlineConf
	for _, path := range []string{
		onlineconf.MakePath(serviceName, "transport/grpc/{{ .Transport.Name }}/host"),
	} {
		var ex bool
		var err error
		host, ex, err = onlineconf.GetStringIfExists(ctx, path)
		if err != nil {
			return nil, errors.Wrap(err, "failed to get host from config")
		}
		if ex {
			break
		}
	}

	for _, path := range []string{
		onlineconf.MakePath(serviceName, "transport/grpc/{{ .Transport.Name }}/port"),
	} {
		var ex bool
		var err error
		port, ex, err = onlineconf.GetStringIfExists(ctx, path)
		if err != nil {
			return nil, errors.Wrap(err, "failed to get port from config")
		}
		if ex {
			break
		}
	}
{{ if .Applications.IsTransportOptional .Transport.Name }}
	if host == "" || port == "" {
		{{ .Logger.InfoMsg "ctx" "gRPC client not configured, skipping" }}
		return nil, nil
	}
{{ else }}
	if host == "" || port == "" {
		return nil, errors.New("host or port not configured")
	}
{{ end }}
	// ToDo timeout

	// Create connection
	address := fmt.Sprintf("%s:%s", host, port)
	//nolint:staticcheck // grpc.DialContext is deprecated but provides better compatibility
	client, err := grpc.DialContext(ctx, address,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to create client for %s", address)
	}

	{{ .Logger.InfoMsg "ctx" "Created gRPC client" "str::address::address" }}

	return &Client{
		client: client,
	}, nil
}

func (c *Client) GetClient() *grpc.ClientConn {
	return c.client
}

func (c *Client) Close() error {
	if c.client != nil {
		return c.client.Close()
	}
	return nil
}
{{ end }}
