package app

import (
	"context"
	"errors"
	"os"
	"os/signal"
	"time"

	{{ .Logger.Import }}
	"golang.org/x/sync/errgroup"
)

type IGracefulShuhtdown interface {
	GracefulStop(ctx context.Context) (<-chan struct{}, error)
	Shutdown(ctx context.Context) error
}

const (
	gracefulShutdownTimeout = 30 * time.Second
	loggerObjectName        = "object"
)

var Interrupt os.Signal = syscall.SIGINT | syscall.SIGTERM | syscall.SIGKILL

func gracefullyShutdown(shutdownCtx context.Context, closer IGracefulShuhtdown, name string) {
	{{ .Logger.InfoMsg "shutdownCtx" "graceful shutdown" "Str(\"Name\", name)"}}
	stopped, err := closer.GracefulStop(shutdownCtx)
	if err != nil {
		err = closer.Shutdown(shutdownCtx)
		if err != nil {
			{{ .Logger.ErrorMsg "shutdownCtx" "err" "can't graceful stop" "Str(\"Name\", name)"}}
		}

		return
	}

	// hard limit
	t := time.NewTimer(gracefulShutdownTimeout)
	select {
	case <-t.C:
		{{ .Logger.InfoMsg "shutdownCtx" "shutdown with 30s deadline" "Str(\"Name\", name)"}}

		err = closer.Shutdown(shutdownCtx)
		if err != nil {
			{{ .Logger.ErrorMsg "shutdownCtx" "err" "can't shutdown" "Str(\"Name\", name)"}}
		}
	case <-stopped:
		t.Stop()
		{{ .Logger.InfoMsg "shutdownCtx" "successfully shutdown" "Str(\"Name\", name)"}}
	}
}

func (a *App) InitGracefulStop(ctx context.Context) context.Context {
	// graceful shutdown
	ctx, a.ctxStop = signal.NotifyContext(ctx, Interrupt)

	// init error group
	a.errGr, ctx = errgroup.WithContext(ctx)

	return ctx
}

func (a *App) gracefulStop(ctx context.Context) error {
	var err error

	a.ready.Store(false) // помечаем, что приложение не готово принимать запросы

	{{ .Logger.InfoMsg "ctx" "transports gracefully shutting down"}}

	shutdownCtx, shutdownCancel := context.WithTimeout(ctx, gracefulShutdownTimeout)
	defer shutdownCancel()

	if len(a.transports) > 0 {
		for _, transport := range a.transports {
			gracefullyShutdown(shutdownCtx, transport, "Transport " + transport.Name())
		}
	} else {
		{{ .Logger.InfoMsg "ctx" "empty transport"}}
	}

	if len(a.workers) > 0 {
		for _, worker := range a.workers {
			gracefullyShutdown(shutdownCtx, worker, "Worker " + worker.Name())
		}
	} else {
		{{ .Logger.InfoMsg "ctx" "empty workers"}}
	}

	if len(a.drivers) > 0 {
		for _, driver := range a.drivers {
			gracefullyShutdown(shutdownCtx, driver, "Driver " + driver.Name())
		}
	} else {
		{{ .Logger.InfoMsg "ctx" "empty driver"}}
	}

	err = a.errGr.Wait()
	if errors.Is(err, context.Canceled) {
		err = nil
	}

	return err
}
