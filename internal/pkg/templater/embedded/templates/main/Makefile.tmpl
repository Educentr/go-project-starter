PWD = $(CURDIR)
# Service name
SERVICE_NAME = {{ .ProjectName }}
# 8 symbols of the last commit
LAST_COMMIT_HASH = $(shell git rev-parse --short=8 HEAD)
# Version of api/buf.yaml buf generator
BUF_VERSION:=1.47.2
# Test timeout
TEST_TIMEOUT?=20s
# Coverage data directory (absolute path required for coverage collection)
COVERAGE_DIR ?= $(CURDIR)/coverage-data
# Coverage filter: exclude *_gen.go, internal/pkg/model/repository/*, pkg/*
COVERAGE_FILTER := _gen\.go\|internal/pkg/model/repository/\|/pkg/
# golang-ci tag
GOLANGCI_TAG:={{ .GolangciVersion }}
# Path to the binary
LOCAL_BIN:=$(CURDIR)/bin
# Путь до бинарника golang-ci
GOLANGCI_BIN:=$(LOCAL_BIN)/golangci-lint
# Minimal Golang version
MIN_GO_VERSION = 1.23.8
# Ogen version
OGENVERSION = {{ .OgenVersion }}
{{ if .UseActiveRecord }}
# activeRecord version
ARGENVERSION = {{ .ArgenVersion }}
{{ end }}
{{- if gt (len .JSONSchemas) 0 }}
# go-jsonschema version
GO_JSONSCHEMA_VERSION = {{ .GoJSONSchemaVersion }}
{{- end }}
{{- if .Applications.HasGoatTests }}
# Goat versions
GOATVERSION = {{ .GoatVersion }}
GOATSERVICESVERSION = {{ .GoatServicesVersion }}
{{- end }}
# Onlineconf version
ONLINECONF_UPDATER_VERSION = v3.6.4
# Build datetime
BUILD_DATE = $(shell TZ=UTC-3 date +%Y%m%d-%H%M)
# Operation system
OSNAME = $(shell uname)
# Build version
ifeq ($(OSNAME),Darwin)
RELEASE ?= $(shell TZ=UTC-3 date -r $(shell git show -s --format=%ct $(shell git rev-parse HEAD) | head -1) '+%Y%m%d-%H%M')
else
RELEASE ?= $(shell git describe --exact-match --tags 2> /dev/null || TZ=UTC-3 date -d @$(shell git show -s --format=%ct $(shell git rev-parse HEAD) | head -1) '+%Y%m%d-%H%M')
endif
# ld flags
LD_FLAGS = -X 'main.BuildCommit=$(LAST_COMMIT_HASH)' -X 'main.Version=$(RELEASE)' -X 'main.BuildTime=$(BUILD_DATE)' -X 'main.BuildOS=$(OSNAME)'
# GOPATH
GOPATH = $(shell go env GOPATH)
GOPROXY ?=https://proxy.golang.org,direct
GOPRIVATE ?=github.com/Educentr{{ if .PrivateRepos }},{{ .PrivateRepos }}{{ end }}
PACKAGE = $(shell go list -m)
PKG_LIST_FOR_TEST = $(shell go list ./...)
PKG_LIST_FOR_UNIT_TEST = $(shell go list ./... | grep -v '/tests$$')

COMMIT_BRANCH = $(shell git branch --no-color --show-current)

# Environment prefix (prod/alpha/beta)
ENVIRONMENT_PREFIX = dev-
ifeq ($(COMMIT_BRANCH), main)
	ENVIRONMENT_PREFIX =
else ifeq ($(COMMIT_BRANCH), alpha)
	ENVIRONMENT_PREFIX = alpha-
else ifeq ($(COMMIT_BRANCH), beta)
	ENVIRONMENT_PREFIX = beta-
endif

# Docker variables
REGISTRY_SERVER ?= {{ .DockerImagePrefix }}
DOCKER_TAG ?= $(ENVIRONMENT_PREFIX)$(RELEASE)-$(LAST_COMMIT_HASH)

# by default 'make' will build the service
default: build

# Add flag to test race condition
ifdef GO_RACE_DETECTOR
    FLAGS += -race
endif

##################### Checks to run golang-ci #####################
# Local bin version check
ifneq ($(wildcard $(GOLANGCI_BIN)),)
GOLANGCI_BIN_VERSION:=$(shell $(GOLANGCI_BIN) --version)
ifneq ($(GOLANGCI_BIN_VERSION),)
GOLANGCI_BIN_VERSION_SHORT:=$(shell echo "$(GOLANGCI_BIN_VERSION)" | sed -E 's/.* version (.*) built from .* on .*/\1/g')
else
GOLANGCI_BIN_VERSION_SHORT:=0
endif
ifneq "$(GOLANGCI_TAG)" "$(word 1, $(sort $(GOLANGCI_TAG) $(GOLANGCI_BIN_VERSION_SHORT)))"
GOLANGCI_BIN:=
endif
endif

# Global bin version check
ifneq (, $(shell which golangci-lint))
GOLANGCI_VERSION:=$(shell golangci-lint --version 2> /dev/null )
ifneq ($(GOLANGCI_VERSION),)
GOLANGCI_VERSION_SHORT:=$(shell echo "$(GOLANGCI_VERSION)"|sed -E 's/.* version (.*) built from .* on .*/\1/g')
else
GOLANGCI_VERSION_SHORT:=0
endif
ifeq "$(GOLANGCI_TAG)" "$(word 1, $(sort $(GOLANGCI_TAG) $(GOLANGCI_VERSION_SHORT)))"
GOLANGCI_BIN:=$(shell which golangci-lint)
endif
endif

.PHONY: regenerate
regenerate:
	go-project-starter --target ${PWD}

##################### End of golang-ci checks #####################
# Initialize git repository (does not require remote to exist)
.PHONY: git-init
git-init:
	@if [ ! -d .git ]; then \
		git init && \
		echo "Git repository initialized"; \
	else \
		echo "Git repository already exists"; \
	fi

# Setup remote and fetch (requires remote repository to exist)
.PHONY: git-remote
git-remote:
	@if ! git remote get-url origin >/dev/null 2>&1; then \
		git remote add origin {{ .Repo }} && \
		echo "Remote 'origin' added: {{ .Repo }}"; \
	fi
	@git fetch origin || echo "Fetch failed (remote may not exist yet). Skip"

# Legacy target for backwards compatibility
.PHONY: git-repo
git-repo: git-init git-remote

# Install linter
.PHONY: install-lint
install-lint:
ifeq ($(wildcard $(GOLANGCI_BIN)),)
	$(info "Downloading golangci-lint v$(GOLANGCI_TAG)")
	tmp=$$(mktemp -d) && cd $$tmp && pwd && go mod init temp && go get -d github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v$(GOLANGCI_TAG) && \
		go build -ldflags "-X 'main.version=$(GOLANGCI_TAG)' -X 'main.commit=test' -X 'main.date=test'" -o $(LOCAL_BIN)/golangci-lint github.com/golangci/golangci-lint/v2/cmd/golangci-lint && \
		rm -rf $$tmp
GOLANGCI_BIN:=$(LOCAL_BIN)/golangci-lint
endif

.PHONY: go-get-u
go-get-u:
	@echo "go get -u all dependencies..."
	@GOPRIVATE=$(GOPRIVATE) go get -d -u ./...

.PHONY: onlineconf-update
onlineconf-update:
	@echo "Update onlineconf..."
	@onlineconf-updater -config etc/onlineconf-updater.conf -once

# Linter will check only diffs with main branch (default)
.PHONY: lint
lint: install-lint
	$(GOLANGCI_BIN) --timeout=5m run --config=./configs/golangci-lint.yml ./... --new-from-rev=origin/main --build-tags=$(SERVICE_NAME) --path-prefix='config/'

# Run full code lint
.PHONY: lint-full
lint-full: lint
	$(GOLANGCI_BIN) --timeout=5m run --config=./configs/golangci-lint.yml ./... --build-tags=$(SERVICE_NAME) --path-prefix='config/'

# Linter will check only diffs with main branch (default)
.PHONY: lint-fix
lint-fix: lint
	$(GOLANGCI_BIN) run --fix --config=./configs/golangci-lint.yml ./... --build-tags=$(SERVICE_NAME)

# Create test coverage report
.PHONY: coverage
coverage:
	go test -timeout=$(TEST_TIMEOUT) -v -coverprofile=coverage.out $(PKG_LIST_FOR_TEST)  && go tool cover -html=coverage.out

# Run an integration testing with all dependencies using a single command
.PHONY: test-integration-with-deps
test-integration-with-deps: test-int-up-deps test-integration

# Up all dependencies required for an integration testing
.PHONY: test-int-up-deps
test-int-up-deps:
	@echo "Up testing dependencies: \n"
	docker-compose up -d --build --force-recreate wiremock
	@echo "Successful up testing dependencies"

# Run unit testing (excludes GOAT integration tests)
.PHONY: unit-tests
unit-tests:
	@echo "Start unit testing $(SERVICE_NAME) \n"
	go test -race -parallel=10 $(PKG_LIST_FOR_UNIT_TEST) -coverprofile=cover.out -timeout=$(TEST_TIMEOUT)

# Run all tests
{{- if .Applications.HasGoatTests }}
.PHONY: test
test: unit-tests goat-tests
{{- else }}
.PHONY: test
test: unit-tests
{{- end }}

.PHONY: dep-ci
dep-ci: ## Install dependencies
	GOPRIVATE=$(GOPRIVATE) go mod download

{{ range $_, $a := .Applications }}
{{ if $a.HasDocker -}}
# Build service {{ $a.Name }} in container
.PHONY: build_in_docker-{{ $a.Name }}
build_in_docker-{{ $a.Name }}:
	go build -o bin/{{ $a.Name }} -ldflags="$(LD_FLAGS)" $(PWD)/cmd/{{ $a.Name }}

# Build docker image for service {{ $a.Name }}
.PHONY: docker-{{ $a.Name }}
docker-{{ $a.Name }}:
	DOCKER_BUILDKIT=1 docker build . -f ./Dockerfile-{{ $a.Name }} --rm --secret id=github_token,env=GITHUB_TOKEN -t $(REGISTRY_SERVER)/$(SERVICE_NAME)-{{ $a.Name }}:${DOCKER_TAG}

.PHONY: docker-{{ $a.Name }}-push
docker-{{ $a.Name }}-push:
	docker push $(REGISTRY_SERVER)/$(SERVICE_NAME)-{{ $a.Name }}:${DOCKER_TAG}
{{ end }}
# Run service {{ $a.Name }}
.PHONY: run-{{ $a.Name }}
run-{{ $a.Name }}: onlineconf-update
	./scripts/goversioncheck.sh $(MIN_GO_VERSION) && OTEL_SERVICE_NAME="$(SERVICE_NAME)-devel" go run -ldflags="$(LD_FLAGS)" $(PWD)/cmd/{{ $a.Name }}/psg_main_gen.go

# Build service {{ $a.Name }}
.PHONY: build-{{ $a.Name }}
build-{{ $a.Name }}:
	./scripts/goversioncheck.sh $(MIN_GO_VERSION) && CGO_ENABLED=0 go build -o bin/{{ $a.Name }} -ldflags="$(LD_FLAGS)" $(PWD)/cmd/{{ $a.Name }}

.PHONY: build_for_test-{{ $a.Name }}
build_for_test-{{ $a.Name }}: download
	CGO_ENABLED=1 go build -cover -race -tags '${TAGS}' -gcflags "all=-N -l" -o /tmp/{{ $a.Name }} ${PACKAGE}/cmd/{{ $a.Name }}
{{ end }}

.PHONY: artifact-list
artifact-list:
	@echo '[{{ range $_, $a := .Applications }}{{ if $a.HasDocker }}"$(SERVICE_NAME)-{{ $a.Name }}:${DOCKER_TAG}", {{ end }}{{ end }}]' | sed 's/, *]$$/]/'

.PHONY: docker-list
docker-list:
	@echo '[{{ range $_, $a := .Applications }}{{ if $a.HasDocker }}"docker-{{ $a.Name }}", {{ end }}{{ end }}]' | sed 's/, *]$$/]/'

.PHONY: docker
docker: {{ range $_, $a := .Applications }}{{ if $a.HasDocker }}docker-{{ $a.Name }} {{ end }}{{ end }}

.PHONY: docker-push
docker-push: {{ range $_, $a := .Applications }}{{ if $a.HasDocker }}docker-{{ $a.Name }}-push {{ end }}{{ end }}

{{ if .Artifacts.HasPackaging }}
# nfpm tool installation
NFPM_VERSION ?= 2.35.3
.PHONY: install-nfpm
install-nfpm:
	go install github.com/goreleaser/nfpm/v2/cmd/nfpm@v$(NFPM_VERSION)

# Package version (deb-compatible format: YYYYMMDD.HHMM+commit or 0~devYYYYMMDD.HHMM+commit)
# Deb versions can't start with letters, dashes replaced with dots
PKG_RELEASE = $(subst -,.,$(RELEASE))
ifeq ($(COMMIT_BRANCH), main)
PKG_VERSION ?= $(PKG_RELEASE).$(LAST_COMMIT_HASH)
else
PKG_VERSION ?= 0~dev$(PKG_RELEASE).$(LAST_COMMIT_HASH)
endif

{{ range $_, $a := .Applications }}{{ if not $a.IsCLI }}
{{ if $a.HasDeb }}
.PHONY: deb-{{ $a.Name }}
deb-{{ $a.Name }}: build-{{ $a.Name }}
	VERSION=$(PKG_VERSION) nfpm package -p deb -f packaging/{{ $a.Name }}/nfpm.yaml
{{ end }}
{{ if $a.HasRPM }}
.PHONY: rpm-{{ $a.Name }}
rpm-{{ $a.Name }}: build-{{ $a.Name }}
	VERSION=$(PKG_VERSION) nfpm package -p rpm -f packaging/{{ $a.Name }}/nfpm.yaml
{{ end }}
{{ if $a.HasAPK }}
.PHONY: apk-{{ $a.Name }}
apk-{{ $a.Name }}: build-{{ $a.Name }}
	VERSION=$(PKG_VERSION) nfpm package -p apk -f packaging/{{ $a.Name }}/nfpm.yaml
{{ end }}
{{ end }}{{ end }}

# Aggregate package targets
.PHONY: packages
packages: {{ range $_, $a := .Applications }}{{ if not $a.IsCLI }}{{ if $a.HasDeb }}deb-{{ $a.Name }} {{ end }}{{ if $a.HasRPM }}rpm-{{ $a.Name }} {{ end }}{{ if $a.HasAPK }}apk-{{ $a.Name }} {{ end }}{{ end }}{{ end }}

.PHONY: package-list
package-list:
	@echo '[{{ range $_, $a := .Applications }}{{ if not $a.IsCLI }}{{ if $a.HasDeb }}"$(SERVICE_NAME)-{{ $a.Name }}_$(PKG_VERSION)_amd64.deb", {{ end }}{{ if $a.HasRPM }}"$(SERVICE_NAME)-{{ $a.Name }}-$(PKG_VERSION).x86_64.rpm", {{ end }}{{ if $a.HasAPK }}"$(SERVICE_NAME)-{{ $a.Name }}-$(PKG_VERSION).apk", {{ end }}{{ end }}{{ end }}]' | sed 's/, *]$$/]/'
{{ end }}

{{ if .Artifacts.HasUpload }}
# Package upload configuration
# Set these environment variables or pass as make arguments:
{{- if .Artifacts.IsS3Compatible }}
#   UPLOAD_BUCKET   - Target bucket name (required)
#   UPLOAD_REGION   - Bucket region (optional, default: us-east-1)
#   UPLOAD_PREFIX   - Path prefix in bucket (optional, default: packages)
{{- if .Artifacts.IsMinio }}
#   UPLOAD_ENDPOINT - MinIO endpoint URL (required for MinIO)
{{- end }}
{{- end }}
{{- if .Artifacts.IsRsync }}
#   UPLOAD_HOST - Target SSH host (required)
#   UPLOAD_PATH - Remote path for packages (required)
#   UPLOAD_USER - SSH username (required)
{{- end }}
UPLOAD_PREFIX ?= packages
{{- if .Artifacts.IsS3Compatible }}
UPLOAD_REGION ?= us-east-1
{{- end }}

# Upload all packages
.PHONY: upload-packages
upload-packages: packages
{{- if .Artifacts.IsMinio }}
	@echo "Uploading packages to MinIO (endpoint: $(UPLOAD_ENDPOINT))..."
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" {{ if $.Artifacts.HasDeb }}--include "*.deb" {{ end }}{{ if $.Artifacts.HasRPM }}--include "*.rpm" {{ end }}{{ if $.Artifacts.HasAPK }}--include "*.apk" {{ end }}--endpoint-url $(UPLOAD_ENDPOINT) --region $(UPLOAD_REGION)
{{- else if .Artifacts.IsAWS }}
	@echo "Uploading packages to AWS S3..."
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" {{ if $.Artifacts.HasDeb }}--include "*.deb" {{ end }}{{ if $.Artifacts.HasRPM }}--include "*.rpm" {{ end }}{{ if $.Artifacts.HasAPK }}--include "*.apk" {{ end }}--region $(UPLOAD_REGION)
{{- else if .Artifacts.IsRsync }}
	@echo "Uploading packages via rsync to $(UPLOAD_USER)@$(UPLOAD_HOST):$(UPLOAD_PATH)..."
	@rsync -avz --progress {{ if $.Artifacts.HasDeb }}*.deb {{ end }}{{ if $.Artifacts.HasRPM }}*.rpm {{ end }}{{ if $.Artifacts.HasAPK }}*.apk {{ end }}$(UPLOAD_USER)@$(UPLOAD_HOST):$(UPLOAD_PATH)/
{{- end }}
	@echo "Upload complete"

{{ if .Artifacts.HasDeb }}
# Upload only deb packages
.PHONY: upload-deb
upload-deb:
{{- if .Artifacts.IsMinio }}
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" --include "*.deb" --endpoint-url $(UPLOAD_ENDPOINT) --region $(UPLOAD_REGION)
{{- else if .Artifacts.IsAWS }}
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" --include "*.deb" --region $(UPLOAD_REGION)
{{- else if .Artifacts.IsRsync }}
	@rsync -avz --progress *.deb $(UPLOAD_USER)@$(UPLOAD_HOST):$(UPLOAD_PATH)/
{{- end }}
{{ end }}
{{ if .Artifacts.HasRPM }}
# Upload only rpm packages
.PHONY: upload-rpm
upload-rpm:
{{- if .Artifacts.IsMinio }}
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" --include "*.rpm" --endpoint-url $(UPLOAD_ENDPOINT) --region $(UPLOAD_REGION)
{{- else if .Artifacts.IsAWS }}
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" --include "*.rpm" --region $(UPLOAD_REGION)
{{- else if .Artifacts.IsRsync }}
	@rsync -avz --progress *.rpm $(UPLOAD_USER)@$(UPLOAD_HOST):$(UPLOAD_PATH)/
{{- end }}
{{ end }}
{{ if .Artifacts.HasAPK }}
# Upload only apk packages
.PHONY: upload-apk
upload-apk:
{{- if .Artifacts.IsMinio }}
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" --include "*.apk" --endpoint-url $(UPLOAD_ENDPOINT) --region $(UPLOAD_REGION)
{{- else if .Artifacts.IsAWS }}
	@aws s3 cp . s3://$(UPLOAD_BUCKET)/$(UPLOAD_PREFIX)/ --recursive --exclude "*" --include "*.apk" --region $(UPLOAD_REGION)
{{- else if .Artifacts.IsRsync }}
	@rsync -avz --progress *.apk $(UPLOAD_USER)@$(UPLOAD_HOST):$(UPLOAD_PATH)/
{{- end }}
{{ end }}
{{ end }}

{{ if .DevStand }}
# Development stand management
.PHONY: dev-up
dev-up:
	docker compose -f docker-compose-dev.yaml up -d

.PHONY: dev-rebuild
dev-rebuild: dev-down
	docker compose -f docker-compose-dev.yaml up -d --build{{ range .Applications }} {{ .Name }}{{ end }}

.PHONY: dev-down
dev-down:
	docker compose -f docker-compose-dev.yaml down

.PHONY: dev-restart
dev-restart:
	docker compose -f docker-compose-dev.yaml restart

.PHONY: dev-drop
dev-drop:
	docker compose -f docker-compose-dev.yaml down -v
{{ end }}
{{ if .Documentation.IsEnabled }}
# Documentation
{{- if .Documentation.IsS3 }}
# Required environment variables for docs-deploy:
#   DOCS_BUCKET   - Target S3 bucket name (required)
#   DOCS_REGION   - Bucket region (optional, default: us-east-1)
#   DOCS_ENDPOINT - S3 endpoint URL (optional, for S3-compatible storage)
#   DOCS_PREFIX   - Path prefix in bucket (optional, default: docs/$(SERVICE_NAME))
DOCS_REGION ?= us-east-1
DOCS_PREFIX ?= docs/$(SERVICE_NAME)
{{- end }}

.PHONY: docs-build
docs-build:
	@echo "Building documentation..."
	@pip install mkdocs-material 2>/dev/null || pip install --user mkdocs-material
	@mkdocs build

.PHONY: docs-serve
docs-serve:
	@mkdocs serve

.PHONY: docs-deploy
{{- if .Documentation.IsS3 }}
docs-deploy: docs-build
	@echo "Deploying documentation to S3..."
	@if [ -n "$(DOCS_ENDPOINT)" ]; then \
		aws s3 sync ./site/ s3://$(DOCS_BUCKET)/$(DOCS_PREFIX)/ --delete --endpoint-url $(DOCS_ENDPOINT) --region $(DOCS_REGION); \
	else \
		aws s3 sync ./site/ s3://$(DOCS_BUCKET)/$(DOCS_PREFIX)/ --delete --region $(DOCS_REGION); \
	fi
	@echo "Documentation deployed"
{{- else if .Documentation.IsGitHubPages }}
docs-deploy:
	@echo "Deploying documentation to GitHub Pages..."
	@pip install mkdocs-material 2>/dev/null || pip install --user mkdocs-material
	@mkdocs gh-deploy --force
{{- end }}
{{ end }}
.PHONY: build
build: {{ range $_, $a := .Applications }}build-{{ $a.Name }} {{ end }}

.PHONE: build-for-test
build-for-test: {{ range $_, $a := .Applications }}build_for_test-{{ $a.Name }} {{ end }}

# Generate pb files from proto description
.PHONY: proto
proto:
{{ $proto := false }}
{{- range $_, $h := .Applications.GetGrpcTransport }}
	{{ $proto = true }}
	@echo "Generating gRPC code for {{ $h.Name }}..."
	{{ if $h.BufLocalPlugins -}}
	@buf generate --template "./configs/transport/grpc/{{ $h.Name }}/buf.gen.yaml" --path ./api/grpc/{{ $h.Name }}
	{{- else -}}
	@docker run --rm -v "$(PWD):/${SERVICE_NAME}" -w "/${SERVICE_NAME}" bufbuild/buf generate --template "./configs/grpc.gen.yaml" --path ./api/grpc/{{ $h.Name }}
	{{- end }}
{{- end }}
{{- range $_, $h := .Applications.GetKafkaTransport }}
	{{ $proto = true }}
	@echo "Generating kafka structs..."
	@docker run --rm -v "$(PWD):/${SERVICE_NAME}" -w "/${SERVICE_NAME}" bufbuild/buf generate --template "./configs/kafka.gen.yaml" --path ./api/kafka/{{ $h.Name }}
{{- end }}
{{ if eq $proto true }}
	@echo "proto done"
{{ else }}
	@echo "No proto files found"
{{ end }}

{{- $projectPath := .ProjectPath }}
{{- $ogen := false }}
{{- range $_, $t := .Applications.GetRestTransport }}
	{{ if or (eq $t.GeneratorType "ogen") (eq $t.GeneratorType "ogen_client") }}
		{{ if eq $ogen false }}
			{{ $ogen = true }}
# Generate oas files from all openapi specifications
.PHONY: generate-ogen
generate-ogen:
		{{ end }}
		{{ if eq $t.GeneratorType "ogen" }}
	# {{ $t.Name }}: {{ $t.Type }}
	@echo "Generating REST code for {{ $t.Name }}..."
	@cd {{ $t.GetTargetSpecDir "" }} && go run github.com/ogen-go/ogen/cmd/ogen@$(OGENVERSION) -config ../../../../{{ $t.GetOgenConfigPath "" }} -target ../../../../{{ $t.GetTargetGeneratePath "" }} -package {{ $t.Name }} {{ $t.GetTargetSpecFile 0 }} && echo "Generated successfully"
		{{ else if eq $t.GeneratorType "ogen_client" }}
	@echo "Generating client REST code for {{ $t.Name }}..."
	@cd {{ $t.GetTargetSpecDir "" }} && go run github.com/ogen-go/ogen/cmd/ogen@$(OGENVERSION) -config ../../../../{{ $t.GetOgenConfigPath "" }} -target ../../../../{{ $t.GetTargetGeneratePath "" }} -package {{ $t.Name }} {{ $t.GetTargetSpecFile 0 }} && echo "Generated successfully"
		{{ else if eq $t.GeneratorType "template" }}
			{{ if 0 }}ToDo Возможно надо сделать возможость что то перегенерировать для темлейтов. Кажется, что нет но надо подумать{{ end }}
		{{ else }}
	# Unknown generator type {{ $t.GeneratorType }}
		@echo "Unknown generator type {{ $t.GeneratorType }} {{ $t.Name }}"
		{{ end }}
	{{ end }}
{{ end }}

{{ if .UseActiveRecord }}
# Generate activerecord files from all openapi specifications
.PHONY: generate-argen
generate-argen:
	argen --path ./internal/pkg/model/repository --declaration "decl" --destination "cmpl" --schema_path etc/database

.PHONY: install-argen
install-argen:
	GOPRIVATE=$(GOPRIVATE) go get github.com/Educentr/go-activerecord/v3@$(ARGENVERSION)
	GOPRIVATE=$(GOPRIVATE) go install github.com/Educentr/go-activerecord/v3/cmd/argen@$(ARGENVERSION)
{{ end }}
{{- $jsonschema := false }}
{{- if gt (len .JSONSchemas) 0 }}
{{ $jsonschema = true }}
# Generate Go structs from JSON Schema files
.PHONY: generate-jsonschema
generate-jsonschema:
{{- range $name, $schema := .JSONSchemas }}
	@echo "Generating Go code from JSON Schema for {{ $name }}..."
	@mkdir -p {{ $schema.GetTargetGeneratePath "" }}
{{- range $_, $filename := $schema.GetSchemaFilenames }}
	@go-jsonschema -p {{ $schema.GetPackageName }} -o {{ $schema.GetTargetGeneratePath "" }}/{{ $filename | ReplaceDash | ToLower }}.go {{ $schema.GetTargetSpecDir "" }}/{{ $filename }}.json
{{- end }}
{{- end }}
	@echo "JSON Schema generation done"

.PHONY: install-go-jsonschema
install-go-jsonschema:
	go install github.com/atombender/go-jsonschema@$(GO_JSONSCHEMA_VERSION)
{{- end }}

{{ if eq $ogen true }}
# ToDo нужно в каждом подключаемом сервисе хранить список необходимых для установки tools-ов и убрать тут проверку, что есто ogen
# Install dependencies for Ogen generator
.PHONY: install-ogen
install-ogen:
	GOPRIVATE=$(GOPRIVATE) go get github.com/ogen-go/ogen@$(OGENVERSION)
	GOPRIVATE=$(GOPRIVATE) go install github.com/ogen-go/ogen/cmd/ogen@$(OGENVERSION)
{{- end }}

{{- if .Applications.HasGoatTests }}
# Install goat and goat-services
.PHONY: install-goat
install-goat:
	GOPRIVATE=$(GOPRIVATE) go get github.com/Educentr/goat@$(GOATVERSION)
	GOPRIVATE=$(GOPRIVATE) go get github.com/Educentr/goat-services@$(GOATSERVICESVERSION)

.PHONY: get-goat
get-goat:
	@echo "Fetching goat..."
	@GOPRIVATE=$(GOPRIVATE) go get github.com/Educentr/goat@$(GOATVERSION)
	@GOPRIVATE=$(GOPRIVATE) go get github.com/Educentr/goat-services@$(GOATSERVICESVERSION)
{{- end }}

# Print release tag
.PHONY: release-tag
release-tag:
	@echo $(DOCKER_TAG)

{{ if eq $proto true }}
# Install dependencies for protobuf generator
.PHONY: install-buf
install-buf:
	mkdir -p "$(shell go env GOPATH)/bin"
	curl -sSL \
    	"https://github.com/bufbuild/buf/releases/download/v${BUF_VERSION}/buf-$(shell uname -s)-$(shell uname -m)" \
    	-o "$(shell go env GOPATH)/bin/buf" && \
  	chmod +x "$(shell go env GOPATH)/bin/buf"

# Install protoc-gen-go and protoc-gen-go-grpc
.PHONY: install-protoc-gen-go-grpc
install-protoc-gen-go-grpc:
	go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
	go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
{{- end }}

# Install local git hooks
.PHONY: install-hooks
install-hooks:
	cp ./scripts/githooks/pre-commit ./.git/hooks/

# Generate mock packages
.PHONY: mock
mock:
	@echo "Generating mocks..."
	@go generate ./...

# Generate test mocks only
.PHONY: generate-mocks
generate-mocks:
	@echo "Generating test mocks..."
	@go generate ./tests/mocks/...


.PHONY: get-runtime
get-runtime:
	@echo "Fetching go-project-starter-runtime..."
	@GOPRIVATE=$(GOPRIVATE) go get github.com/Educentr/go-project-starter-runtime@{{ .RuntimeVersion }}

.PHONY: tidy
tidy: get-runtime
	@echo "go mod tidy..."
	@GOPRIVATE=$(GOPRIVATE) go mod tidy


.PHONY: clean-import
clean-import:
	@echo "cleaning imports..."
	@goimports -w .

{{- $pg := false }}
{{- $sqlc := false }}

# ToDo work with databases

{{- if eq $pg true }}
{{ if eq $sqlc true }}
.PHONY: install-sqlc
install-sqlc:
	@go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest

.PHONY: sqlc
sqlc:
	@$(shell go env GOPATH)/bin/sqlc generate -f $(SQLC_PATH)
{{ else }}
ToDo select driver for PG
{{- end }}
{{- end }}

.PHONY: install-goimports
install-goimports:
	go install golang.org/x/tools/cmd/goimports@latest

.PHONY: install-onlineconf-updater
install-onlineconf-updater:
	go install github.com/Nikolo/onlineconf/onlineconf-updater/v3@$(ONLINECONF_UPDATER_VERSION)

# Install dependencies for tools
.PHONY: install-tools
install-tools: install-hooks install-onlineconf-updater install-lint {{ if eq $proto true }}install-buf install-protoc-gen-go-grpc {{ end }}{{ if eq $ogen true }}install-ogen {{ end }}{{ if .UseActiveRecord }}install-argen {{ end }}{{ if eq $jsonschema true }}install-go-jsonschema {{ end }}{{ if eq $pg true }}install-sqlc {{ end }}install-goimports

# Generate mock packages
#TODO: enable ansible generator after debugging
#generate-ansible
.PHONY: generate
generate: proto {{ if $ogen }}generate-ogen {{ end }}{{ if eq $sqlc true }}sqlc{{ end }}{{ if .UseActiveRecord }}generate-argen {{ end }}{{ if eq $jsonschema true }}generate-jsonschema {{ end }}

.PHONY: download
download:
	@GOPRIVATE=$(GOPRIVATE) go mod download

{{ if .Applications.HasGoatTests }}
# GOAT integration tests
.PHONY: onlineconf-update-tests
onlineconf-update-tests:
	@echo "Update onlineconf tests..."
	@onlineconf-updater -config tests/etc/onlineconf-updater.conf -once

{{ range $_, $a := .Applications }}{{ if $a.GoatTests }}
.PHONY: generate-test-env-{{ $a.Name }}
generate-test-env-{{ $a.Name }}:
	@if [ ! -f tests/etc/onlineconf/onlineconf.env ]; then \
		echo "onlineconf.env not found, preparing environment..."; \
		$(MAKE) install-onlineconf-updater || true; \
		$(MAKE) onlineconf-update-tests || true; \
	fi
	@echo "Generating tests/etc/onlineconf/onlineconf.env..."
	@go run github.com/Educentr/goat/cmd/testutil@$(GOATVERSION) generate-env

.PHONY: goat-tests-{{ $a.Name }}
goat-tests-{{ $a.Name }}: build_for_test-{{ $a.Name }} generate-test-env-{{ $a.Name }}
	@rm -rf $(COVERAGE_DIR)
	@mkdir -p $(COVERAGE_DIR)
	export GOAT_DISABLE_STDOUT=true \
	&& export GOCOVERDIR=$(COVERAGE_DIR) \
	&& go test ./tests
	@echo "Converting coverage data..."
	@go tool covdata textfmt -i=$(COVERAGE_DIR) -o=integration-coverage-raw.out 2>/dev/null || true
	@if [ -f integration-coverage-raw.out ]; then \
		echo "Filtering coverage..."; \
		head -1 integration-coverage-raw.out > integration-coverage.out; \
		tail -n +2 integration-coverage-raw.out | grep -v '$(COVERAGE_FILTER)' >> integration-coverage.out || true; \
		go tool cover -html=integration-coverage.out -o=integration-coverage.html 2>/dev/null; \
		echo "Coverage report: integration-coverage.html"; \
		echo ""; \
		echo "=== Coverage Summary (filtered) ==="; \
		go tool cover -func=integration-coverage.out | tail -1; \
	else \
		echo "No coverage data collected"; \
	fi

.PHONY: goat-tests-{{ $a.Name }}-verbose
goat-tests-{{ $a.Name }}-verbose: build_for_test-{{ $a.Name }} generate-test-env-{{ $a.Name }}
	@rm -rf $(COVERAGE_DIR)
	@mkdir -p $(COVERAGE_DIR)
	GOCOVERDIR=$(COVERAGE_DIR) go test -v ./tests/...
	@go tool covdata textfmt -i=$(COVERAGE_DIR) -o=integration-coverage-raw.out 2>/dev/null || true
	@if [ -f integration-coverage-raw.out ]; then \
		head -1 integration-coverage-raw.out > integration-coverage.out; \
		tail -n +2 integration-coverage-raw.out | grep -v '$(COVERAGE_FILTER)' >> integration-coverage.out || true; \
		go tool cover -html=integration-coverage.out -o=integration-coverage.html 2>/dev/null; \
		echo "=== Coverage Summary (filtered) ==="; \
		go tool cover -func=integration-coverage.out | tail -1; \
	fi

.PHONY: goat-coverage-percent
goat-coverage-percent:
	@test -f integration-coverage.out || (echo "Run 'make goat-tests-{{ $a.Name }}' first" && exit 1)
	@echo "=== Coverage Summary (filtered) ==="
	@go tool cover -func=integration-coverage.out | tail -1

# Alias for backward compatibility
.PHONY: goat-tests
goat-tests: goat-tests-{{ $a.Name }}
{{ end }}{{ end }}
{{ end }}

#ToDo integration tests GITEF
