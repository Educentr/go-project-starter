package service

import (
	"context"
	"net/url"
	"strconv"
	"time"

	"github.com/Educentr/go-onlineconf/pkg/onlineconf"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"

	"{{ .ProjectPath }}/internal/app/constant"
	{{ range $_, $tr := .Applications.GetRestTransport }}
	{{ if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) }}
	{{ range $_, $imp := $tr.Import }}
	{{ $imp }}
	{{- end }}
	{{- end }}
	{{- end }}
	{{ range $_, $tr := .Applications.GetGrpcTransport }}
	{{ if eq $tr.GeneratorType "buf_client" }}
	{{ range $_, $imp := $tr.Import }}
	{{ $imp }}
	{{- end }}
	{{- end }}
	{{- end }}
	
	{{ range $_, $driver := .Drivers }}
	"{{ $driver.Import }}"
	{{ end }}
	{{ range $_, $kafka := .Kafka }}
	{{ if not $kafka.IsCustomDriver }}
	"{{ $kafka.GetImport $.ProjectPath }}"
	{{ end }}
	{{ end }}

	{{ .Logger.Import }}

	"{{ .ProjectPath }}/pkg/app/rest"
	"github.com/Educentr/go-project-starter-runtime/pkg/reqctx"
	"github.com/Educentr/go-project-starter-runtime/pkg/ds"
	"github.com/Educentr/go-project-starter-runtime/pkg/app/healthstate"
	"github.com/Educentr/go-project-starter-runtime/pkg/app/serviceauth"
	"github.com/Educentr/go-project-starter-runtime/pkg/servicemetrics"
)

type Service struct {
	healthstate.Service
	servicemetrics.EmptyMetrics
	serviceauth.Authorizer
	{{ range $_, $tr := .Applications.GetRestTransport }}
	{{ if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) }}
	{{ $tr.Name | ToLower }} *{{ $tr.PkgName }}.Client
	{{ end }}
	{{ end }}
	{{ range $_, $tr := .Applications.GetGrpcTransport }}
	{{ if eq $tr.GeneratorType "buf_client" }}
	{{ $tr.Name | ToLower }} *{{ $tr.Name }}Client.Client
	{{ end }}
	{{ end }}
	{{ range $_, $driver := .Drivers }}
	{{ $driver.Name | ToLower }} *{{ $driver.Package }}.{{ $driver.ObjName }}
	{{ if ne $driver.ServiceInjection "" }}
	{{ $driver.ServiceInjection}}
	{{ end }}
	{{ end }}
	{{ range $_, $kafka := .Kafka }}
	{{ if eq $kafka.Type "producer" }}
	{{ $kafka.Name | ToLower }} *{{ $kafka.GetPackage }}.{{ $kafka.GetObjName }}
	{{ end }}
	{{ end }}
}

{{- range $_, $tr := .Applications.GetRestTransport }}
{{- if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) ($.Applications.IsTransportOptional $tr.Name) }}

func (s *Service) tryGet{{ $tr.Name | CapitalizeFirst }}(ctx context.Context, fn func(*{{ $tr.PkgName }}.Client) error) {
	if s.{{ $tr.Name | ToLower }} == nil {
		{{ $.Logger.WarnMsg "ctx" (printf "%s client is nil, skipping" $tr.Name) }}
		return
	}
	if err := fn(s.{{ $tr.Name | ToLower }}); err != nil {
		{{ $.Logger.ErrorMsg "ctx" "err" (printf "can't execute %s client callback" $tr.Name) }}
	}
}
{{- end }}
{{- end }}
{{- range $_, $tr := .Applications.GetGrpcTransport }}
{{- if and (eq $tr.GeneratorType "buf_client") ($.Applications.IsTransportOptional $tr.Name) }}

func (s *Service) tryGet{{ $tr.Name | CapitalizeFirst }}(ctx context.Context, fn func(*{{ $tr.Name }}Client.Client) error) {
	if s.{{ $tr.Name | ToLower }} == nil {
		{{ $.Logger.WarnMsg "ctx" (printf "%s gRPC client is nil, skipping" $tr.Name) }}
		return
	}
	if err := fn(s.{{ $tr.Name | ToLower }}); err != nil {
		{{ $.Logger.ErrorMsg "ctx" "err" (printf "can't execute %s gRPC client callback" $tr.Name) }}
	}
}
{{- end }}
{{- end }}
{{- range $_, $driver := .Drivers }}
{{- if ($.Applications.IsDriverOptional $driver.Name) }}

func (s *Service) tryGet{{ $driver.Name | CapitalizeFirst }}(ctx context.Context, fn func(*{{ $driver.Package }}.{{ $driver.ObjName }}) error) {
	if s.{{ $driver.Name | ToLower }} == nil {
		{{ $.Logger.WarnMsg "ctx" (printf "%s driver is nil, skipping" $driver.Name) }}
		return
	}
	if err := fn(s.{{ $driver.Name | ToLower }}); err != nil {
		{{ $.Logger.ErrorMsg "ctx" "err" (printf "can't execute %s driver callback" $driver.Name) }}
	}
}
{{- end }}
{{- end }}
{{- range $_, $kafka := .Kafka }}
{{- if eq $kafka.Type "producer" }}
{{- if ($.Applications.IsKafkaOptional $kafka.Name) }}

func (s *Service) tryGet{{ $kafka.Name | CapitalizeFirst }}(ctx context.Context, fn func(*{{ $kafka.GetPackage }}.{{ $kafka.GetObjName }}) error) {
	if s.{{ $kafka.Name | ToLower }} == nil {
		{{ $.Logger.WarnMsg "ctx" (printf "%s kafka producer is nil, skipping" $kafka.Name) }}
		return
	}
	if err := fn(s.{{ $kafka.Name | ToLower }}); err != nil {
		{{ $.Logger.ErrorMsg "ctx" "err" (printf "can't execute %s kafka producer callback" $kafka.Name) }}
	}
}
{{- end }}
{{- end }}
{{- end }}
{{- range $_, $app := .Applications }}

func (s *Service) ValidateFor{{ $app.Name | CapitalizeFirst }}() error {
	var missing []string
	{{- range $_, $tr := $app.GetRestTransport }}
	{{- if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) (not $tr.Optional) }}
	if s.{{ $tr.Name | ToLower }} == nil {
		missing = append(missing, "{{ $tr.Name }} (REST client)")
	}
	{{- end }}
	{{- end }}
	{{- range $_, $tr := $app.GetGrpcTransport }}
	{{- if and (eq $tr.GeneratorType "buf_client") (not $tr.Optional) }}
	if s.{{ $tr.Name | ToLower }} == nil {
		missing = append(missing, "{{ $tr.Name }} (gRPC client)")
	}
	{{- end }}
	{{- end }}
	{{- range $_, $driver := $app.Drivers }}
	{{- if not $driver.Optional }}
	if s.{{ $driver.Name | ToLower }} == nil {
		missing = append(missing, "{{ $driver.Name }} (driver)")
	}
	{{- end }}
	{{- end }}
	{{- range $_, $kafka := $app.GetKafkaProducers }}
	{{- if not $kafka.Optional }}
	if s.{{ $kafka.Name | ToLower }} == nil {
		missing = append(missing, "{{ $kafka.Name }} (kafka producer)")
	}
	{{- end }}
	{{- end }}
	if len(missing) > 0 {
		return errors.Errorf("service validation failed for app {{ $app.Name }}: missing dependencies: %v", missing)
	}
	return nil
}
{{- end }}

type ActionEnableUsers string

const (
	LoginAction ActionEnableUsers = "login"
)

func (s *Service) HitInfo(ctx context.Context, method string, u *url.URL, status int, contentLength int, ip string, contentType string, userAgent string, referer string, execTime float64) {
} 

func (s *Service) BotHitInfo(ctx context.Context, processInfo reqctx.RequestProcessInfo, status string, contentLength int, execTime time.Duration) {
}

func UserEnabled(ctx context.Context, tgID int64, action ActionEnableUsers) (bool, error) {
	enabledUsers, err := onlineconf.GetStrings(ctx, onlineconf.MakePath(constant.ServiceName, "settings", "enabled", string(action)), []string{})
	if err != nil {
		return false, err
	}

	if len(enabledUsers) == 0 {
		_, ex, err := onlineconf.GetStringIfExists(ctx, onlineconf.MakePath(constant.ServiceName, "settings", "enabled", string(action)))
		if err != nil {
			return false, err
		}

		if !ex {
			// если нету ключа значит включено для всех
			return true, nil
		}

		_, ex, err = onlineconf.GetStringIfExists(ctx, onlineconf.MakePath(constant.ServiceName, "settings", "enabled", string(action), strconv.FormatInt(tgID, 10)))
		if err != nil {
			return false, err
		}

		return ex, nil
	}


	if len(enabledUsers) == 1 && enabledUsers[0] == "full" {
		return true, nil
	}
	
	enableUsersInt := make(map[int64]struct{}, len(enabledUsers))

	for _, eu := range enabledUsers {
		uID, err := strconv.ParseInt(eu, 10, 64)
		if err != nil {
			{{ .Logger.ErrorMsg "ctx" "err" "error parse user_id" "Str(\"user_id\", eu)"}}

			continue
		}

		enableUsersInt[uID] = struct{}{}
	}

	if _, ex := enableUsersInt[tgID]; ex {
		return true, nil
	}

	return false, nil
}

func NewService(ctx context.Context) (ds.IService, error) {
	srv := &Service{}

	return srv.Init(ctx)
}

{{ if or (ne 0 ( len .Drivers )) (ne 0 ( len .Kafka )) }}
func (s *Service) setDrivers(drvs []ds.Runnable) error {
	for _, drv := range drvs {
		switch d := drv.(type) {
		{{ range $_, $driver := .Drivers }}
		case *{{ $driver.Package }}.{{ $driver.ObjName }}:
			s.{{ $driver.Name | ToLower }} = d
		{{ end }}
		{{ range $_, $kafka := .Kafka }}
		{{ if eq $kafka.Type "producer" }}
		case *{{ $kafka.GetPackage }}.{{ $kafka.GetObjName }}:
			s.{{ $kafka.Name | ToLower }} = d
		{{ end }}
		{{ end }}
		default:
			return errors.Errorf("unknown driver type: %T", drv)
		}
	}

	return nil
}
{{ end }}

{{ $hasOgenClients := false }}
{{ range $_, $tr := .Applications.GetRestTransport }}
{{ if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) }}{{ $hasOgenClients = true }}{{ end }}
{{ end }}
{{ $hasGrpcClients := false }}
{{ range $_, $tr := .Applications.GetGrpcTransport }}
{{ if eq $tr.GeneratorType "buf_client" }}{{ $hasGrpcClients = true }}{{ end }}
{{ end }}
{{ if or $hasOgenClients $hasGrpcClients }}
func (s *Service) setClients(ctx context.Context, clients []ds.ClientInitializer) error {
	var err error
	for _, cln := range clients {
		switch c := cln.(type) {
		{{ range $_, $tr := .Applications.GetRestTransport }}
		{{ if and (eq $tr.GeneratorType "ogen_client") (not $tr.IsDynamic) }}
		case *{{ $tr.Name }}.Client:
			s.{{ $tr.Name | ToLower }}, err = c.GetClient{{ $tr.Name }}(ctx)
			if err != nil {
				return errors.Wrap(err, "error init {{ $tr.Name }} client")
			}
		{{- end }}
		{{- end }}
		{{ range $_, $tr := .Applications.GetGrpcTransport }}
		{{ if eq $tr.GeneratorType "buf_client" }}
		case *{{ $tr.Name }}Client.ClientWrapper:
			s.{{ $tr.Name | ToLower }}, err = c.Init(ctx, constant.ServiceName)
			if err != nil {
				return errors.Wrap(err, "error init {{ $tr.Name }} gRPC client")
			}
		{{- end }}
		{{- end }}
		default:
			return errors.Errorf("unknown client type: %T", cln)
		}
	}
	return nil
}
{{ else }}
func (s *Service) setClients(_ context.Context, _ []ds.ClientInitializer) error {
	return nil
}
{{ end }}

{{ if not .SkipServiceInit }}
var (
	errAppReadyNil = errors.New("app ready pointer can't be nil")
	errAppInfoNil  = errors.New("app info pointer can't be nil")
)

func (s *Service) Init(_ context.Context) (*EmptyService, error) {
	return &EmptyService{
		Service: s,
	}, nil
}

//nolint:decorder
type EmptyService struct {
	*Service
}

func (s *EmptyService) InitService(ctx context.Context, drvs []ds.Runnable, clients []ds.ClientInitializer, bucket ds.ServerBucket, m *prometheus.Registry) error {
	err := s.InitState(ctx, drvs, bucket, m)
	if err != nil {
		return errors.Wrap(err, "error init state")
	}

	err = s.InitMetrics(ctx, constant.ServiceName, m)
	if err != nil {
		return errors.Wrap(err, "error init metrics")
	}

	// Initialize clients from the passed list
	err = s.setClients(ctx, clients)
	if err != nil {
		return errors.Wrap(err, "error init clients")
	}

	{{ if or (ne 0 ( len .Drivers )) (ne 0 ( len .Kafka )) }}
	return s.setDrivers(drvs)
	{{ else }}
	return nil
	{{ end }}
}
{{ end }}

type EmptyServiceToHandle struct{}

func (h *EmptyServiceToHandle) GetEmptySrv(aSrv any) (*EmptyService, error) {
	srv, ok := aSrv.(*EmptyService)
	if !ok {
		return nil, rest.ErrServiceType
	}

	return srv, nil
}
