package setup

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/AlecAivazis/survey/v2"
)

// SecretInfo contains secret metadata with description
type SecretInfo struct {
	Name        string
	Value       string
	Description string
	CreateURL   string
	Optional    bool
}

const (
	registryTypeGitHub       = "github"
	registryTypeDigitalOcean = "digitalocean"
	registryTypeAWS          = "aws"
	registryTypeSelfHosted   = "selfhosted"

	placeholderSSHKey  = "<your-deploy-ssh-private-key>"
	defaultDeployUser  = "deploy"
	cliArgBody         = "--body"
	formatKeyValue     = "  %s: %s\n"
	formatFailedSetVar = "Failed to set variable %s: %v"
	codeBlockDelimiter = "```"
	codeBlockBash      = "```bash"
	shellEscapeQuote   = "'\\''"
	ghCLI              = "gh"

	// URLs for creating tokens
	//nolint:gosec // G101: these are URLs, not credentials
	urlGitHubTokens = "https://github.com/settings/tokens/new?scopes=repo,write:packages,read:packages"
	//nolint:gosec // G101: these are URLs, not credentials
	urlDOTokens = "https://cloud.digitalocean.com/account/api/tokens"
	urlAWSKeys  = "https://console.aws.amazon.com/iam/home#/security_credentials"

	ghSubCommandSet     = "set"
	ghSubCommandList    = "list"
	ghSubCommandSecret  = "secret"
	ghSubCommandVar     = "variable"
	formatCreateAt      = "    Create at: %s\n"
	secretsPreallocSize = 16

	// SSH key related constants
	sshKeyTypeRSA           = "rsa"
	defaultKeyName          = "id_rsa"
	formatKeyNotFound       = "Key not found: %s"
	formatSSHKeyGenerated   = "SSH key generated: %s"
	warnNoSSHKeysFound      = "No existing SSH keys found in ~/.ssh"
	formatPubKeyForServer   = "\nPublic key (ensure it's in server's authorized_keys):\n"
	formatPubKeyForDeployer = "\nPublic key (add to server's authorized_keys for deploy user):\n"
	formatFailedSavePubKey  = "Failed to save public key: %v"
)

// getGitHubUsername returns the currently logged in GitHub username via gh CLI
func getGitHubUsername() string {
	cmd := exec.Command(ghCLI, "api", "user", "--jq", ".login")
	output, err := cmd.Output()

	if err != nil {
		return ""
	}

	return strings.TrimSpace(string(output))
}

// setupGitHub configures GitHub Actions secrets and variables
func (s *Setup) setupGitHub() error {
	// Check if gh CLI is available
	ghAvailable := isCommandAvailable("gh")

	if ghAvailable {
		PrintInfo("GitHub CLI (gh) detected. Will use it to configure secrets and variables.")
	} else {
		PrintWarning("GitHub CLI (gh) not found. Will provide manual instructions.")
	}

	// Generate secrets
	secrets := s.generateGitHubSecrets()
	variables := s.generateGitHubVariables()

	if ghAvailable {
		return s.setupGitHubWithCLI(secrets, variables)
	}

	return s.printGitHubManualInstructions(secrets, variables)
}

// generateGitHubSecrets generates the list of secrets needed
func (s *Setup) generateGitHubSecrets() []SecretInfo {
	// Preallocate with estimated capacity (base secrets + registry + optional + notifications + onlineconf)
	secrets := make([]SecretInfo, 0, secretsPreallocSize)

	// SSH secrets
	secrets = append(secrets, SecretInfo{
		Name:        "SSH_PRIVATE_KEY",
		Value:       placeholderSSHKey,
		Description: "Private SSH key for deploying to servers (generated by setup or your own)",
	})
	secrets = append(secrets, SecretInfo{
		Name:        "SSH_USER",
		Value:       defaultDeployUser,
		Description: "SSH user for deployment",
	})

	// Registry secrets based on type
	secrets = append(secrets, SecretInfo{
		Name:        "REGISTRY_LOGIN_SERVER",
		Value:       s.SetupConfig.Registry.Server,
		Description: "Docker registry server address",
	})

	switch s.SetupConfig.Registry.Type {
	case registryTypeGitHub:
		ghUser := getGitHubUsername()
		if ghUser == "" {
			ghUser = "<your-github-username>"
		}

		secrets = append(secrets, SecretInfo{
			Name:        "GHCR_USER",
			Value:       ghUser,
			Description: "GitHub username for container registry",
		})
		secrets = append(secrets, SecretInfo{
			Name:        "GHCR_TOKEN",
			Value:       "<your-github-token>",
			Description: "GitHub token with write:packages scope for pushing images",
			CreateURL:   urlGitHubTokens,
		})
	case registryTypeDigitalOcean:
		secrets = append(secrets, SecretInfo{
			Name:        "REGISTRY_PASSWORD",
			Value:       "<your-digitalocean-api-token>",
			Description: "DigitalOcean API token for container registry",
			CreateURL:   urlDOTokens,
		})
	case registryTypeAWS:
		secrets = append(secrets, SecretInfo{
			Name:        "AWS_ACCESS_KEY_ID",
			Value:       "<your-aws-access-key>",
			Description: "AWS access key for ECR",
			CreateURL:   urlAWSKeys,
		})
		secrets = append(secrets, SecretInfo{
			Name:        "AWS_SECRET_ACCESS_KEY",
			Value:       "<your-aws-secret-key>",
			Description: "AWS secret key for ECR",
		})
		secrets = append(secrets, SecretInfo{
			Name:        "AWS_REGION",
			Value:       "<your-aws-region>",
			Description: "AWS region (e.g., us-east-1)",
		})
	case registryTypeSelfHosted:
		secrets = append(secrets, SecretInfo{
			Name:        "REGISTRY_URL",
			Value:       s.SetupConfig.Registry.Server,
			Description: "Self-hosted registry URL",
		})
		secrets = append(secrets, SecretInfo{
			Name:        "REGISTRY_USERNAME",
			Value:       "<your-registry-username>",
			Description: "Registry username",
		})
		secrets = append(secrets, SecretInfo{
			Name:        "REGISTRY_PASSWORD",
			Value:       "<your-registry-password>",
			Description: "Registry password",
		})
	}

	// Note: GH_PAT for private Go modules is not asked here.
	// If build fails due to private deps, user can add it manually.

	// Notifications
	if s.SetupConfig.Notifications.Telegram.Enabled {
		secrets = append(secrets, SecretInfo{
			Name:        "TELEGRAM_BOT_TOKEN",
			Value:       s.SetupConfig.Notifications.Telegram.BotToken,
			Description: "Telegram bot token for CI/CD notifications",
		})
		secrets = append(secrets, SecretInfo{
			Name:        "TELEGRAM_CHAT_ID",
			Value:       s.SetupConfig.Notifications.Telegram.ChatID,
			Description: "Telegram chat ID for notifications",
		})
	}

	if s.SetupConfig.Notifications.Slack.Enabled {
		secrets = append(secrets, SecretInfo{
			Name:        "ACTION_MONITORING_SLACK",
			Value:       s.SetupConfig.Notifications.Slack.WebhookURL,
			Description: "Slack webhook URL for CI/CD notifications",
		})
	}

	// OnlineConf secrets per branch (only if enabled)
	for _, env := range s.SetupConfig.Environments {
		if !env.OnlineConf.Enabled {
			continue
		}

		branch := strings.ToUpper(env.Branch)
		secrets = append(secrets, SecretInfo{
			Name:        fmt.Sprintf("%s_OC_USER", branch),
			Value:       fmt.Sprintf(`["%s"]`, env.OnlineConf.User),
			Description: fmt.Sprintf("OnlineConf username for %s environment", env.Name),
		})
		secrets = append(secrets, SecretInfo{
			Name:        fmt.Sprintf("%s_OC_PASSWORD", branch),
			Value:       `["<onlineconf-password>"]`,
			Description: fmt.Sprintf("OnlineConf password for %s environment", env.Name),
		})
	}

	return secrets
}

// generateGitHubVariables generates the list of variables needed
func (s *Setup) generateGitHubVariables() map[string]string {
	variables := make(map[string]string)

	// Registry container
	variables["REGISTRY_CONTAINER"] = s.SetupConfig.Registry.Container

	// Per-branch variables
	for _, env := range s.SetupConfig.Environments {
		branch := strings.ToUpper(env.Branch)

		variables[fmt.Sprintf("%s_ENABLED", branch)] = "ENABLED"

		// Build SSH hosts and env types from deployments
		var sshHosts [][]string

		var envTypes []string

		for _, deployment := range env.Deployments {
			server := s.SetupConfig.GetServerByName(deployment.Server)
			if server == nil {
				continue
			}
			// Each deployment becomes a row: [public_ip, internal_ip]
			sshHosts = append(sshHosts, []string{server.Host, server.Host})
			envTypes = append(envTypes, deployment.Server) // Use server name as env type
		}

		sshHostJSON, _ := json.Marshal(sshHosts)
		variables[fmt.Sprintf("%s_SSH_HOST", branch)] = string(sshHostJSON)

		envTypeJSON, _ := json.Marshal(envTypes)
		variables[fmt.Sprintf("%s_ENV_TYPE", branch)] = string(envTypeJSON)

		// OnlineConf (only if enabled)
		if env.OnlineConf.Enabled && env.OnlineConf.Host != "" {
			variables[fmt.Sprintf("%s_OC_HOST", branch)] = env.OnlineConf.Host
			variables[fmt.Sprintf("%s_OC_PORT", branch)] = fmt.Sprintf("%d", env.OnlineConf.Port)
		}

		// Internal subnet
		if env.InternalSubnet != "" {
			variables[fmt.Sprintf("%s_INTERNAL_SUBNET", branch)] = env.InternalSubnet
		}

		// Apps per deployment (server)
		for i, deployment := range env.Deployments {
			appsJSON, _ := json.Marshal(deployment.Apps)
			variables[fmt.Sprintf("%s_APPS_%d", branch, i)] = string(appsJSON)
		}

		// Port prefixes for applications
		for _, app := range s.SetupConfig.Applications {
			appName := strings.ToUpper(strings.ReplaceAll(app.Name, "-", "_"))

			// Build array of port prefixes (one per deployment)
			var portPrefixes []string

			for range env.Deployments {
				portPrefixes = append(portPrefixes, fmt.Sprintf("%d", app.PortPrefix))
			}

			portJSON, _ := json.Marshal(portPrefixes)
			variables[fmt.Sprintf("%s_PORT_PREFIX_%s", branch, appName)] = string(portJSON)

			// If app has domain, add domain variable
			if app.Domain != "" {
				var domains []string

				for range env.Deployments {
					domains = append(domains, app.Domain)
				}

				domainJSON, _ := json.Marshal(domains)
				variables[fmt.Sprintf("%s_DOMAIN_%s", branch, appName)] = string(domainJSON)
			}
		}
	}

	return variables
}

// setupGitHubWithCLI uses gh CLI to configure secrets and variables
func (s *Setup) setupGitHubWithCLI(secrets []SecretInfo, variables map[string]string) error {
	repo := s.SetupConfig.CI.Repo

	fmt.Println("\nConfiguring GitHub secrets...")
	s.configureGitHubSecrets(secrets, repo)

	fmt.Println("\nConfiguring GitHub variables...")
	s.configureGitHubVariables(variables, repo)

	// Verify all secrets and variables are set
	if !s.DryRun {
		s.verifyGitHubSecretsAndVariables(secrets, variables)
	}

	return nil
}

// configureGitHubSecrets sets secrets via gh CLI
func (s *Setup) configureGitHubSecrets(secrets []SecretInfo, repo string) {
	reader := bufio.NewReader(os.Stdin)

	for _, secret := range secrets {
		value := s.promptForSecretValue(secret, reader)
		if value == "" {
			continue
		}

		if s.DryRun {
			fmt.Printf("  [DRY-RUN] Would set secret: %s\n", secret.Name)

			continue
		}

		//nolint:gosec // G204: gh CLI with user-provided secret name is intentional
		cmd := exec.Command(ghCLI, ghSubCommandSecret, ghSubCommandSet, secret.Name, "-R", repo, cliArgBody, value)
		if err := cmd.Run(); err != nil {
			PrintError(fmt.Sprintf("Failed to set secret %s: %v", secret.Name, err))
		} else {
			PrintSuccess(fmt.Sprintf("Set secret: %s", secret.Name))
		}
	}
}

// promptForSecretValue prompts user for secret value if it's a placeholder
func (s *Setup) promptForSecretValue(secret SecretInfo, reader *bufio.Reader) string {
	value := secret.Value

	if !strings.Contains(value, "<") {
		return value
	}

	// This is a placeholder - ask for actual value
	fmt.Printf("\n--- Secret: %s ---\n", secret.Name)
	fmt.Printf("Description: %s\n", secret.Description)

	if secret.CreateURL != "" {
		fmt.Printf("Create at: %s\n", secret.CreateURL)
	}

	if value == placeholderSSHKey {
		// Handle SSH key specially - offer to generate or use existing
		return s.handleSSHKeySecret()
	}

	if secret.Optional {
		fmt.Print("Enter value (or press Enter to skip): ")
	} else {
		fmt.Print("Enter value: ")
	}

	line, err := reader.ReadString('\n')
	if err != nil {
		PrintWarning(fmt.Sprintf("Skipping %s - failed to read input", secret.Name))

		return ""
	}

	actualValue := strings.TrimSpace(line)

	if actualValue == "" {
		if secret.Optional {
			PrintInfo(fmt.Sprintf("Skipping optional secret %s", secret.Name))
		} else {
			PrintWarning(fmt.Sprintf("Skipping %s - no value provided", secret.Name))
		}

		return ""
	}

	return actualValue
}

// handleSSHKeySecret handles SSH_PRIVATE_KEY specially - offers to generate or use existing key
func (s *Setup) handleSSHKeySecret() string {
	repo := s.SetupConfig.CI.Repo

	// Check if SSH_PRIVATE_KEY already exists in GitHub
	existingSecrets, err := getExistingGitHubSecrets(repo)
	if err == nil && existingSecrets["SSH_PRIVATE_KEY"] {
		PrintInfo("SSH_PRIVATE_KEY already configured in GitHub")

		return ""
	}

	// Offer options
	var keyChoice string

	keyPrompt := &survey.Select{
		Message: "SSH_PRIVATE_KEY is not configured. What would you like to do?",
		Options: []string{
			"Generate new SSH key",
			"Use existing SSH key",
			"Skip (configure manually later)",
		},
		Default: "Generate new SSH key",
	}

	if err := survey.AskOne(keyPrompt, &keyChoice); err != nil {
		PrintWarning("Failed to get user input, skipping SSH key")

		return ""
	}

	switch keyChoice {
	case "Generate new SSH key":
		s.generateAndUploadSSHKeyForCI()
	case "Use existing SSH key":
		s.selectAndUploadSSHKeyForCI()
	default:
		PrintInfo("Skipping SSH key. Configure SSH_PRIVATE_KEY manually later.")
	}

	// Return empty - key is uploaded directly, not through normal flow
	return ""
}

// generateAndUploadSSHKeyForCI generates a new SSH key and uploads to GitHub
func (s *Setup) generateAndUploadSSHKeyForCI() {
	projectName := s.GetProjectName()
	keyPath := filepath.Join(os.Getenv(envHome), sshDir, fmt.Sprintf("%s_deploy_id_rsa", projectName))
	pubKeyPath := keyPath + pubKeyExtension

	// Check if public key already exists - warn about regeneration consequences
	if _, err := os.Stat(pubKeyPath); err == nil {
		PrintWarning("SSH key already exists for this project!")
		fmt.Println("  Regenerating will break deployments on servers where old key is configured.")
		fmt.Println("  You will need to update authorized_keys on all servers.")

		var regenerate bool

		regenPrompt := &survey.Confirm{
			Message: "Regenerate SSH key anyway?",
			Default: false,
		}

		if err := survey.AskOne(regenPrompt, &regenerate); err != nil || !regenerate {
			// Use existing key instead
			PrintInfo(fmt.Sprintf("Using existing key: %s", keyPath))
			//nolint:errcheck // error is logged inside uploadSSHKeyToGitHub
			s.uploadSSHKeyToGitHub(keyPath)

			return
		}

		// Remove old keys before regeneration
		os.Remove(keyPath)
		os.Remove(pubKeyPath)
	}

	PrintInfo("Generating new SSH deploy key...")

	// Generate key
	cmd := exec.Command(sshKeygenCommand, "-q", "-t", sshKeyTypeRSA, "-f", keyPath, "-N", "")
	if err := cmd.Run(); err != nil {
		PrintError(fmt.Sprintf("Failed to generate SSH key: %v", err))

		return
	}

	PrintSuccess(fmt.Sprintf(formatSSHKeyGenerated, keyPath))

	// Show public key
	if pubKey, err := os.ReadFile(pubKeyPath); err == nil {
		fmt.Print(formatPubKeyForDeployer)
		fmt.Println(string(pubKey))
	}

	// Upload to GitHub
	//nolint:errcheck // error is logged inside uploadSSHKeyToGitHub
	s.uploadSSHKeyToGitHub(keyPath)
}

// selectAndUploadSSHKeyForCI prompts for existing key and uploads to GitHub
func (s *Setup) selectAndUploadSSHKeyForCI() {
	defaultSSHDir := filepath.Join(os.Getenv(envHome), sshDir)

	// List existing keys
	var existingKeys []string

	files, err := os.ReadDir(defaultSSHDir)
	if err == nil {
		for _, f := range files {
			if !f.IsDir() && strings.HasSuffix(f.Name(), pubKeyExtension) {
				keyName := strings.TrimSuffix(f.Name(), pubKeyExtension)
				existingKeys = append(existingKeys, filepath.Join(defaultSSHDir, keyName))
			}
		}
	}

	if len(existingKeys) == 0 {
		PrintWarning(warnNoSSHKeysFound)

		return
	}

	// Add custom path option
	existingKeys = append(existingKeys, optionCustomPath)

	var selectedKey string

	keyPathPrompt := &survey.Select{
		Message: "Select SSH key to use:",
		Options: existingKeys,
	}

	if err := survey.AskOne(keyPathPrompt, &selectedKey); err != nil {
		return
	}

	// Handle custom path
	if selectedKey == optionCustomPath {
		customPrompt := &survey.Input{
			Message: "Enter path to private key:",
			Default: filepath.Join(defaultSSHDir, defaultKeyName),
		}

		if err := survey.AskOne(customPrompt, &selectedKey); err != nil {
			return
		}
	}

	// Verify key exists
	if _, err := os.Stat(selectedKey); os.IsNotExist(err) {
		PrintError(fmt.Sprintf(formatKeyNotFound, selectedKey))

		return
	}

	// Ensure public key exists (generate from private if needed)
	pubKeyPath := selectedKey + pubKeyExtension
	pubKey := s.ensurePublicKeyExists(selectedKey, pubKeyPath)

	if pubKey != "" {
		fmt.Print(formatPubKeyForServer)
		fmt.Println(pubKey)
	}

	// Save public key to project-specific path for reuse in setup server
	s.savePublicKeyForProject(pubKeyPath)

	// Upload to GitHub
	//nolint:errcheck // error is logged inside uploadSSHKeyToGitHub
	s.uploadSSHKeyToGitHub(selectedKey)
}

// ensurePublicKeyExists checks if public key exists, generates it if not
func (s *Setup) ensurePublicKeyExists(privKeyPath, pubKeyPath string) string {
	// Try to read existing public key
	if pubKey, err := os.ReadFile(pubKeyPath); err == nil {
		return strings.TrimSpace(string(pubKey))
	}

	// Generate public key from private key
	PrintInfo("Generating public key from private key...")

	cmd := exec.Command(sshKeygenCommand, "-y", "-f", privKeyPath)
	output, err := cmd.Output()

	if err != nil {
		PrintWarning(fmt.Sprintf("Failed to generate public key: %v", err))

		return ""
	}

	pubKey := strings.TrimSpace(string(output))

	// Save public key
	if err := os.WriteFile(pubKeyPath, []byte(pubKey+"\n"), filePermPublic); err != nil {
		PrintWarning(fmt.Sprintf(formatFailedSavePubKey, err))
	} else {
		PrintSuccess(fmt.Sprintf("Public key saved: %s", pubKeyPath))
	}

	return pubKey
}

// savePublicKeyForProject saves public key to project-specific path for reuse in setup server
func (s *Setup) savePublicKeyForProject(pubKeyPath string) {
	projectName := s.GetProjectName()
	targetPubPath := filepath.Join(os.Getenv(envHome), sshDir, fmt.Sprintf("%s_deploy_id_rsa%s", projectName, pubKeyExtension))

	// Skip if source and target are the same
	if pubKeyPath == targetPubPath {
		return
	}

	// Copy public key only
	pubKey, err := os.ReadFile(pubKeyPath)
	if err != nil {
		PrintWarning(fmt.Sprintf("Failed to read public key: %v", err))

		return
	}

	if err := os.WriteFile(targetPubPath, pubKey, filePermPublic); err != nil {
		PrintWarning(fmt.Sprintf(formatFailedSavePubKey, err))

		return
	}

	PrintInfo(fmt.Sprintf("Public key saved to: %s (for reuse in setup server)", targetPubPath))
}

// configureGitHubVariables sets variables via gh CLI
func (s *Setup) configureGitHubVariables(variables map[string]string, repo string) {
	for name, value := range variables {
		if s.DryRun {
			fmt.Printf("  [DRY-RUN] Would set variable: %s = %s\n", name, value)

			continue
		}

		cmd := exec.Command(ghCLI, ghSubCommandVar, ghSubCommandSet, name, "-R", repo, cliArgBody, value)
		if err := cmd.Run(); err != nil {
			PrintError(fmt.Sprintf(formatFailedSetVar, name, err))
		} else {
			PrintSuccess(fmt.Sprintf("Set variable: %s", name))
		}
	}
}

// printGitHubManualInstructions prints manual setup instructions
func (s *Setup) printGitHubManualInstructions(secrets []SecretInfo, variables map[string]string) error {
	repo := s.SetupConfig.CI.Repo

	fmt.Printf("\n=== GitHub Manual Setup Instructions ===\n")
	fmt.Printf("\nGo to: https://github.com/%s/settings/secrets/actions\n", repo)

	fmt.Println("\n--- Secrets to create ---")

	for _, secret := range secrets {
		optStr := ""
		if secret.Optional {
			optStr = " (optional)"
		}

		fmt.Printf("  %s: %s%s\n", secret.Name, secret.Value, optStr)
		fmt.Printf("    Description: %s\n", secret.Description)

		if secret.CreateURL != "" {
			fmt.Printf(formatCreateAt, secret.CreateURL)
		}
	}

	fmt.Printf("\nGo to: https://github.com/%s/settings/variables/actions\n", repo)

	fmt.Println("\n--- Variables to create ---")

	for name, value := range variables {
		fmt.Printf(formatKeyValue, name, value)
	}

	// Also print gh commands for copy-paste
	fmt.Println("\n--- Or use these gh commands ---")
	fmt.Println(codeBlockBash)

	for _, secret := range secrets {
		escapedValue := strings.ReplaceAll(secret.Value, "'", shellEscapeQuote)
		fmt.Printf("gh secret set %s -R %s --body '%s'\n", secret.Name, repo, escapedValue)
	}

	for name, value := range variables {
		escapedValue := strings.ReplaceAll(value, "'", shellEscapeQuote)
		fmt.Printf("gh variable set %s -R %s --body '%s'\n", name, repo, escapedValue)
	}

	fmt.Println(codeBlockDelimiter)

	return nil
}

// isCommandAvailable checks if a command is available in PATH
func isCommandAvailable(name string) bool {
	_, err := exec.LookPath(name)
	return err == nil
}

// getExistingGitHubSecrets returns list of existing secret names in the repo
func getExistingGitHubSecrets(repo string) (map[string]bool, error) {
	cmd := exec.Command(ghCLI, ghSubCommandSecret, ghSubCommandList, "-R", repo)
	output, err := cmd.Output()

	if err != nil {
		return nil, fmt.Errorf("failed to list secrets: %w", err)
	}

	secrets := make(map[string]bool)

	for _, line := range strings.Split(string(output), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		// gh secret list output format: "NAME\tUPDATED"
		parts := strings.Fields(line)
		if len(parts) > 0 {
			secrets[parts[0]] = true
		}
	}

	return secrets, nil
}

// getExistingGitHubVariables returns list of existing variable names in the repo
func getExistingGitHubVariables(repo string) (map[string]bool, error) {
	cmd := exec.Command(ghCLI, ghSubCommandVar, ghSubCommandList, "-R", repo)
	output, err := cmd.Output()

	if err != nil {
		return nil, fmt.Errorf("failed to list variables: %w", err)
	}

	variables := make(map[string]bool)

	for _, line := range strings.Split(string(output), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		// gh variable list output format: "NAME\tVALUE\tUPDATED"
		parts := strings.Fields(line)
		if len(parts) > 0 {
			variables[parts[0]] = true
		}
	}

	return variables, nil
}

// verifyGitHubSecretsAndVariables checks if all required secrets and variables exist
func (s *Setup) verifyGitHubSecretsAndVariables(secrets []SecretInfo, variables map[string]string) {
	repo := s.SetupConfig.CI.Repo

	fmt.Println("\n--- Verifying GitHub configuration ---")

	// Get existing secrets and variables
	existingSecrets, existingVariables, ok := s.fetchExistingGitHubConfig(repo)
	if !ok {
		return
	}

	// Find missing secrets
	missingSecrets := findMissingSecrets(secrets, existingSecrets)

	// Find missing variables
	missingVariables := findMissingVariables(variables, existingVariables)

	// Report results
	if len(missingSecrets) == 0 && len(missingVariables) == 0 {
		PrintSuccess("All secrets and variables are configured!")

		return
	}

	printMissingSecrets(missingSecrets, repo)
	printMissingVariables(missingVariables, variables, repo)

	fmt.Println("\nAfter setting missing values, run 'go-project-starter setup ci' again to verify.")
}

// fetchExistingGitHubConfig fetches existing secrets and variables from GitHub
func (s *Setup) fetchExistingGitHubConfig(repo string) (map[string]bool, map[string]bool, bool) {
	existingSecrets, err := getExistingGitHubSecrets(repo)
	if err != nil {
		PrintWarning(fmt.Sprintf("Could not verify secrets: %v", err))

		return nil, nil, false
	}

	existingVariables, err := getExistingGitHubVariables(repo)
	if err != nil {
		PrintWarning(fmt.Sprintf("Could not verify variables: %v", err))

		return nil, nil, false
	}

	return existingSecrets, existingVariables, true
}

// findMissingSecrets returns secrets that don't exist in GitHub
func findMissingSecrets(secrets []SecretInfo, existing map[string]bool) []SecretInfo {
	var missing []SecretInfo

	for _, secret := range secrets {
		if !existing[secret.Name] {
			missing = append(missing, secret)
		}
	}

	return missing
}

// findMissingVariables returns variable names that don't exist in GitHub
func findMissingVariables(variables map[string]string, existing map[string]bool) []string {
	var missing []string

	for name := range variables {
		if !existing[name] {
			missing = append(missing, name)
		}
	}

	return missing
}

// printMissingSecrets prints information about missing secrets
func printMissingSecrets(missingSecrets []SecretInfo, repo string) {
	if len(missingSecrets) == 0 {
		return
	}

	fmt.Printf("\n⚠ Missing secrets (%d):\n", len(missingSecrets))

	for _, secret := range missingSecrets {
		fmt.Printf("  • %s - %s\n", secret.Name, secret.Description)

		if secret.CreateURL != "" {
			fmt.Printf(formatCreateAt, secret.CreateURL)
		}
	}

	fmt.Printf("\nTo set secrets manually:\n")
	fmt.Println(codeBlockBash)

	for _, secret := range missingSecrets {
		fmt.Printf("gh secret set %s -R %s\n", secret.Name, repo)
	}

	fmt.Println(codeBlockDelimiter)
}

// printMissingVariables prints information about missing variables
func printMissingVariables(missingVariables []string, variables map[string]string, repo string) {
	if len(missingVariables) == 0 {
		return
	}

	fmt.Printf("\n⚠ Missing variables (%d):\n", len(missingVariables))

	for _, name := range missingVariables {
		fmt.Printf("  • %s = %s\n", name, variables[name])
	}

	fmt.Printf("\nTo set variables manually:\n")
	fmt.Println(codeBlockBash)

	for _, name := range missingVariables {
		escapedValue := strings.ReplaceAll(variables[name], "'", shellEscapeQuote)
		fmt.Printf("gh variable set %s -R %s --body '%s'\n", name, repo, escapedValue)
	}

	fmt.Println(codeBlockDelimiter)
}
