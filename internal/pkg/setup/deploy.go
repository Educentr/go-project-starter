package setup

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// generateDeployScript generates the deploy.sh script
func (s *Setup) generateDeployScript() error {
	projectName := s.GetProjectName()
	apps := s.GetApplications()

	if len(apps) == 0 {
		PrintWarning(warnNoApplicationsInYAML)
		return nil
	}

	// Generate deploy script content
	script := s.buildDeployScript(projectName, apps)

	// Determine output path
	outputPath := filepath.Join(s.TargetDir, "scripts", "deploy.sh")
	if s.TargetDir == "" {
		outputPath = "scripts/deploy.sh"
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create scripts directory: %w", err)
	}

	if s.DryRun {
		fmt.Printf("[DRY-RUN] Would generate deploy.sh:\n%s\n", script)
		return nil
	}

	// Write the script (needs to be executable)
	//nolint:gosec // deploy.sh needs execute permissions
	if err := os.WriteFile(outputPath, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to write deploy.sh: %w", err)
	}

	PrintSuccess(fmt.Sprintf("Generated deploy script: %s", outputPath))

	// Also print instructions for server
	fmt.Println("\n--- Deploy Script Installation ---")
	fmt.Printf("Copy the deploy.sh script to /opt/%s-cd/ on your servers:\n", projectName)
	fmt.Printf("  scp %s user@server:/opt/%s-cd/deploy.sh\n", outputPath, projectName)

	return nil
}

// buildDeployScript creates the deploy.sh content
func (s *Setup) buildDeployScript(projectName string, apps []string) string {
	var sb strings.Builder

	sb.WriteString("#!/bin/bash\n")
	sb.WriteString("set -e\n\n")
	sb.WriteString(fmt.Sprintf("cd /opt/%s-cd\n\n", projectName))

	// Add environment detection
	sb.WriteString("# Detect environment from branch\n")
	sb.WriteString("BRANCH=${CI_COMMIT_REF_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'main')}\n")
	sb.WriteString("ENV_TYPE=${ENV_TYPE:-}\n\n")

	// Build env file name
	sb.WriteString("# Build env file name\n")
	sb.WriteString("ENV_FILE=\"envs/.env.${BRANCH}\"\n")
	sb.WriteString("if [ -n \"$ENV_TYPE\" ]; then\n")
	sb.WriteString("    ENV_FILE=\"${ENV_FILE}-${ENV_TYPE}\"\n")
	sb.WriteString("fi\n\n")

	sb.WriteString("echo \"Deploying with env file: $ENV_FILE\"\n\n")

	// Check env file exists
	sb.WriteString("if [ ! -f \"$ENV_FILE\" ]; then\n")
	sb.WriteString("    echo \"Error: Environment file $ENV_FILE not found\"\n")
	sb.WriteString("    exit 1\n")
	sb.WriteString("fi\n\n")

	// Rollout each application
	sb.WriteString("# Rolling update for each application\n")
	for _, app := range apps {
		sb.WriteString(fmt.Sprintf("echo \"Rolling out %s...\"\n", app))
		sb.WriteString(fmt.Sprintf("docker rollout -f docker-compose-%s.yaml --env-file \"$ENV_FILE\" -p %s %s\n\n",
			app, app, app))
	}

	sb.WriteString("echo \"Deployment completed successfully\"\n")

	return sb.String()
}

// GenerateDockerComposeFiles generates docker-compose files for each application
// This is called from the main generator, not from setup
func (s *Setup) GenerateDockerComposeFiles() error {
	apps := s.GetApplications()

	for _, app := range apps {
		if err := s.generateDockerComposeForApp(app); err != nil {
			return err
		}
	}

	return nil
}

// generateDockerComposeForApp generates a docker-compose file for a single application
func (s *Setup) generateDockerComposeForApp(app string) error {
	// This would be a template-based generation
	// For now, just print a reminder

	PrintInfo(fmt.Sprintf("Note: docker-compose-%s.yaml should be generated by the main generator", app))
	return nil
}

// GenerateServerDeployScript generates deploy.sh directly to the server via SSH
func (s *Setup) GenerateServerDeployScript(env EnvironmentConfig) error {
	projectName := s.GetProjectName()
	apps := s.GetApplications()

	script := s.buildDeployScript(projectName, apps)

	// Use heredoc to write script via SSH
	command := fmt.Sprintf(`cat > /opt/%s-cd/deploy.sh << 'DEPLOYEOF'
%s
DEPLOYEOF
chmod +x /opt/%s-cd/deploy.sh`, projectName, script, projectName)

	commands := []string{command}

	PrintManualInstructions(fmt.Sprintf("Create deploy.sh on %s:", env.Server.Host), commands)
	return nil
}
