package setup

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// generateDeployScript generates the deploy.sh script
func (s *Setup) generateDeployScript() error {
	projectName := s.GetProjectName()
	apps := s.GetApplications()

	if len(apps) == 0 {
		PrintWarning(warnNoApplicationsInYAML)
		return nil
	}

	// Generate deploy script content
	script := s.buildDeployScript(projectName, apps)

	// Determine output path
	outputPath := filepath.Join(s.TargetDir, "scripts", "deploy.sh")
	if s.TargetDir == "" {
		outputPath = "scripts/deploy.sh"
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create scripts directory: %w", err)
	}

	if s.DryRun {
		fmt.Printf("[DRY-RUN] Would generate deploy.sh:\n%s\n", script)
		return nil
	}

	// Write the script (needs to be executable)
	//nolint:gosec // deploy.sh needs execute permissions
	if err := os.WriteFile(outputPath, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to write deploy.sh: %w", err)
	}

	PrintSuccess(fmt.Sprintf("Generated deploy script: %s", outputPath))

	// Also print instructions for server
	fmt.Println("\n--- Deploy Script Installation ---")
	fmt.Printf("Copy the deploy.sh script to /opt/%s-cd/ on your servers:\n", projectName)
	fmt.Printf("  scp %s user@server:/opt/%s-cd/deploy.sh\n", outputPath, projectName)

	return nil
}

// buildDeployScript creates the deploy.sh content
func (s *Setup) buildDeployScript(projectName string, apps []string) string {
	var sb strings.Builder

	sb.WriteString("#!/bin/bash\n")
	sb.WriteString("set -e\n\n")
	sb.WriteString(fmt.Sprintf("cd /opt/%s-cd\n\n", projectName))

	// Add environment detection
	sb.WriteString("# Detect environment from branch\n")
	sb.WriteString("BRANCH=${CI_COMMIT_REF_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'main')}\n")
	sb.WriteString("ENV_TYPE=${ENV_TYPE:-}\n\n")

	// Build env file name
	sb.WriteString("# Build env file name\n")
	sb.WriteString("ENV_FILE=\"envs/.env.${BRANCH}\"\n")
	sb.WriteString("if [ -n \"$ENV_TYPE\" ]; then\n")
	sb.WriteString("    ENV_FILE=\"${ENV_FILE}-${ENV_TYPE}\"\n")
	sb.WriteString("fi\n\n")

	sb.WriteString("echo \"Deploying with env file: $ENV_FILE\"\n\n")

	// Check env file exists
	sb.WriteString("if [ ! -f \"$ENV_FILE\" ]; then\n")
	sb.WriteString("    echo \"Error: Environment file $ENV_FILE not found\"\n")
	sb.WriteString("    exit 1\n")
	sb.WriteString("fi\n\n")

	// Rollout each application
	sb.WriteString("# Rolling update for each application\n")
	for _, app := range apps {
		sb.WriteString(fmt.Sprintf("echo \"Rolling out %s...\"\n", app))
		sb.WriteString(fmt.Sprintf("docker rollout -f docker-compose-%s.yaml --env-file \"$ENV_FILE\" -p %s %s\n\n",
			app, app, app))
	}

	sb.WriteString("echo \"Deployment completed successfully\"\n")

	return sb.String()
}

// GenerateDockerComposeFiles generates docker-compose files for each application
// This is called from the main generator, not from setup
func (s *Setup) GenerateDockerComposeFiles() error {
	apps := s.GetApplications()

	for _, app := range apps {
		if err := s.generateDockerComposeForApp(app); err != nil {
			return err
		}
	}

	return nil
}

// generateDockerComposeForApp generates a docker-compose file for a single application
func (s *Setup) generateDockerComposeForApp(app string) error {
	// This would be a template-based generation
	// For now, just print a reminder

	PrintInfo(fmt.Sprintf("Note: docker-compose-%s.yaml should be generated by the main generator", app))
	return nil
}

// GenerateServerDeployScript generates deploy.sh directly to the server via SSH
// serverName is the server name from config, apps is the list of apps to deploy on this server
func (s *Setup) GenerateServerDeployScript(serverName string, apps []string) error {
	projectName := s.GetProjectName()

	if len(apps) == 0 {
		apps = s.GetApplications() // fallback to all apps
	}

	script := s.buildDeployScript(projectName, apps)

	// Use heredoc to write script via SSH
	command := fmt.Sprintf(`cat > /opt/%s-cd/deploy.sh << 'DEPLOYEOF'
%s
DEPLOYEOF
chmod +x /opt/%s-cd/deploy.sh`, projectName, script, projectName)

	commands := []string{command}

	server := s.SetupConfig.GetServerByName(serverName)
	if server != nil {
		PrintManualInstructions(fmt.Sprintf("Create deploy.sh on %s (%s):", serverName, server.Host), commands)
	} else {
		PrintManualInstructions(fmt.Sprintf("Create deploy.sh on %s:", serverName), commands)
	}

	return nil
}

// GenerateAllServerDeployScripts generates deploy.sh for all servers based on deployments
func (s *Setup) GenerateAllServerDeployScripts() error {
	projectName := s.GetProjectName()

	// Collect apps per server across all environments
	serverApps := make(map[string]map[string]bool)

	for _, env := range s.SetupConfig.Environments {
		for _, deployment := range env.Deployments {
			if serverApps[deployment.Server] == nil {
				serverApps[deployment.Server] = make(map[string]bool)
			}

			for _, app := range deployment.Apps {
				serverApps[deployment.Server][app] = true
			}
		}
	}

	// Generate deploy script for each server
	for serverName, appsMap := range serverApps {
		var apps []string
		for app := range appsMap {
			apps = append(apps, app)
		}

		server := s.SetupConfig.GetServerByName(serverName)
		if server == nil {
			PrintWarning(fmt.Sprintf("Server %s not found in config", serverName))
			continue
		}

		script := s.buildDeployScript(projectName, apps)

		fmt.Printf("\n--- Deploy script for %s (%s) ---\n", serverName, server.Host)
		fmt.Println("Applications:", strings.Join(apps, ", "))
		fmt.Println()

		// Print script content
		fmt.Println(script)

		// Print copy command
		outputPath := filepath.Join(s.TargetDir, "scripts", fmt.Sprintf("deploy-%s.sh", serverName))
		fmt.Printf("\nTo deploy: scp %s %s@%s:/opt/%s-cd/deploy.sh\n",
			outputPath, server.DeployUser, server.Host, projectName)
	}

	return nil
}
